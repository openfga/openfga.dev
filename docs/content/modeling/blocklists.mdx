---
sidebar_position: 8
slug: /modeling/blocklists
description: Preventing certain users from accessing objects
---

import {
  AuthzModelSnippetViewer,
  CardBox,
  CheckRequestViewer,
  DocumentationNotice,
  Playground,
  ProductConcept,
  ProductName,
  ProductNameFormat,
  RelatedSection,
  RelationshipTuplesViewer,
  WriteRequestViewer,
} from '@components/Docs';

# Blocklists

<DocumentationNotice />

In this guide you'll see how to model preventing users from accessing objects using <ProductName format={ProductNameFormat.ProductLink}/>. For example, `blocking` users from accessing a `document`, even if it has been already shared with them.

<CardBox title="When to use" appearance="filled">

Exclusion is useful while building applications. You may need to support access patterns like granting access to some users, but excluding specific people or groups, similar to how users can block others from following them on social media, or prevent them from sharing documents on Google Drive.

This is useful when:

- Implementing the "blocking" feature, such as the profile blocking commonly present on social media platforms (e.g. Instagram and Twitter).
- Reduce a user's access if they are part of a particular group (e.g. restricting access to members who are also guests, or restricting access to users in a certain locality).

</CardBox>

## Before you start

Before you start this guide, make sure you're familiar with some <ProductConcept /> and know how to develop the things listed below.


You will start with the _<ProductConcept section="what-is-an-authorization-model" linkName="authorization model" />_ below, it represents a `document` _<ProductConcept section="what-is-a-type" linkName="type" />_ that can have users **<ProductConcept section="what-is-a-relation" linkName="related" />** as `editor`, and `team` type that can have users related as `member`.



<AuthzModelSnippetViewer
  configuration={{
    schema_version: '1.1',
    type_definitions: [
      {
        type: 'user',
      },
      {
        type: 'document',
        relations: {
          editor: {
            this: {},
          },
        },
        metadata: {
          relations: {
            editor: { directly_related_user_types: [{ type: 'user' }, { type: 'team', relation: 'member' }] },
          },
        },
      },
      {
        type: 'team',
        relations: {
          member: {
            this: {},
          },
        },
        metadata: {
          relations: {
            member: { directly_related_user_types: [{ type: 'user' }] },
          },
        },
      },
    ],
  }}
/>

Let us also assume that we have a `document` called "planning", shared for editing within the product `team` (comprised of becky and carl).

```yaml
  # Becky is a member of the product team
  - user: user:becky
    relation: member
    object: team:product

  # Carl is a member of the product team
  - user: user:carl
    relation: member
    object: team:product

  # Members of the product team can edit the planning document
  - user: team:product#member
    relation: editor
    object: document:planning
```


<hr />



## Step by step

With the above authorization model and relationship tuples, <ProductName format={ProductNameFormat.LongForm} /> will correctly respond with `{"allowed":true}` when <ProductConcept section="what-is-a-check-request" linkName="check" /> is called to see if Carl and Becky can edit this `document`.

We can verify that with these two tests which will pass:

```yaml
tests:
  - name: "Becky can edit the 'planning' document"
    check:
      - user: user:becky
        object: document:planning
        assertions:
          editor: true
  - name: "Carl can edit the 'planning' document"
    check:
      - user: user:carl
        object: document:planning
        assertions:
          editor: true
```
We want to share a document with the product team and also have the ability to deny certain users access, even if they have the document shared with them already. We can verify this by blocking Carl (who we have seen already has edit access) from editing the document.

In order to do that, we need to:

1. [Modify our model to allow indicating that users can be blocked from accessing a document](#01-modify-our-model-so-users-can-be-blocked-from-accessing-a-document)
2. [Modify our model to indicate that users who are blocked can no longer edit the document](#02-modify-our-model-so-users-who-are-blocked-can-no-longer-edit-the-document)
3. [Verify that our solution works](#03-verify-our-solution-works):

  a. [Indicate that Carl is blocked from the planning document](#a-indicate-that-carl-is-blocked-from-the-planning-document)
  
  b. [Carl (now blocked) can no longer edit the document](#b-carl-now-blocked-can-no-longer-edit-the-document), but Becky still has edit access

### 01. Modify our model so users can be blocked from accessing a document

To allow users to be "blocked" from accessing a `document`, we first need to allow this relation. We'll update our store model to add a `blocked` <ProductConcept section="what-is-a-relation" linkName="relation" /> to the `document` type.

The authorization model becomes this:

<AuthzModelSnippetViewer
  configuration={{
    schema_version: '1.1',
    type_definitions: [
      {
        type: 'user',
      },
      {
        type: 'document',
        relations: {
          blocked: {
            this: {},
          },
          editor: {
            this: {},
          },
        },
        metadata: {
          relations: {
            blocked: { directly_related_user_types: [{ type: 'user' }] },
            editor: { directly_related_user_types: [{ type: 'user' }, { type: 'team', relation: 'member' }] },
          },
        },
      },
      {
        type: 'team',
        relations: {
          member: {
            this: {},
          },
        },
        metadata: {
          relations: {
            member: { directly_related_user_types: [{ type: 'user' }] },
          },
        },
      },
    ],
  }}
/>

Now we can add relationship tuples indicating that a certain user is `blocked` from editing a `document`.

### 02. Modify our model so users who are blocked can no longer edit the document

Now that we can mark users as `blocked` from editing documents, we need to support denying the `editor` relationship when a user is `blocked`. We do that by modifying the relation definition of `editor`, and making use of the [**exclusion operator**](../configuration-language.mdx#the-exclusion-operator) to exclude the set of `blocked` users, as we can see here:

<AuthzModelSnippetViewer
  configuration={{
    schema_version: '1.1',
    type_definitions: [
      {
        type: 'user',
      },
      {
        type: 'document',
        relations: {
          blocked: {
            this: {},
          },
          editor: {
            difference: {
              base: {
                this: {},
              },
              subtract: {
                computedUserset: {
                  relation: 'blocked',
                },
              },
            },
          },
        },
        metadata: {
          relations: {
            blocked: { directly_related_user_types: [{ type: 'user' }] },
            editor: { directly_related_user_types: [{ type: 'user' }, { type: 'team', relation: 'member' }] },
          },
        },
      },
      {
        type: 'team',
        relations: {
          member: {
            this: {},
          },
        },
        metadata: {
          relations: {
            member: { directly_related_user_types: [{ type: 'user' }] },
          },
        },
      },
    ],
  }}
/>

### 03. Verify our solution works

To check if our new model works, we'll add a relationship tuple with Carl as `blocked` from `document:planning` and then verify that Carl no longer has `editor` access to that document.

#### a. Indicate that Carl is blocked from the planning document

With our modified authorization model, we can indicate that Carl is blocked by adding this _<ProductConcept section="what-is-a-relationship-tuple" linkName="relationship tuple" />_.

```yaml
  # Carl is blocked from the planning document
  - user: user:carl
    relation: blocked
    object: document:planning
```

#### b. Carl (now blocked) can no longer edit the document

We have modified the authorization model and added relationship tuples to indicate that Carl is `blocked`. Now let's make sure our solution works as expected.

With these tuples, Carl will not be able to edit the document, but Becky will:
```yaml
tests:
  - name: "Carl can edit the 'planning' document"
    check:
      - user: user:carl
        object: document:planning
        assertions:
          editor: false
  - name: "Becky can edit the 'planning' document"
    check:
      - user: user:becky
        object: document:planning
        assertions:
          editor: true
```

:::caution
When creating tuples for <ProductName format={ProductNameFormat.LongForm} /> make sure to use unique ids for each object and user within your application domain. We are using first names and human-readable identifiers to make this task easier to read.
:::

## Related Sections

<RelatedSection
  description="Check the following sections for more on how to model with {ProductName}."
  relatedLinks={[
    {
      title: 'Modeling: Getting Started',
      description: 'Learn about how to get started with modeling.',
      link: './getting-started',
      id: './getting-started',
    },
    {
      title: 'Configuration Language',
      description: 'Learn about {ProductName} Configuration Language.',
      link: '../configuration-language',
      id: '../configuration-language',
    },
    {
      title: 'Public Access',
      description: 'Learn about model public access.',
      link: './public-access',
      id: './public-access',
    },
  ]}
/>
