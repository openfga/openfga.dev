---
title: OpenFGA Adoption Patterns
sidebar_position: 3
slug: /getting-started/adoption-patterns
description: Describe different ways OpenFGA can be adopted in an organization
---
# OpenFGA Adoption Patterns

This document discusses several patterns that we've seen <ProductName format={ProductNameFormat.ShortForm}/> users adopting when implementing it.

In general, these patterns are relevant when you already have an existing application that you need to migrate, or when you operate in an organization with multiple development teams that need to adopt <ProductName format={ProductNameFormat.ShortForm}/>


## Starting with coarse-grained access control

If you are reading this document, is probably because realized that your current authorization system is not capable of supporting your current or future needs and you are evaluating <ProductName format={ProductNameFormat.ShortForm}/>.

Some companies decide to start using <ProductName format={ProductNameFormat.ShortForm}/>  by replicating what they currently have. Instead of re-architecting their apps introducing granular permissions, they model their coarse-grained permissions first. 

If your application is currently using Role-Based Access control, you can try defining those roles first. Most <ProductName format={ProductNameFormat.ShortForm}/> implementations are for B2B scenarios where you need to implement multi-tenancy together with RBAC. A simple model representing that use case would be:

```
model 
  schema 1.1

  type user
  type organization
    relations
      define admin : [user]
      define member : [user]
      # .. add aditional organization roles

      # map permissions to organization roles 
      define can_add_member : admin
      define can_delete_member : admin
      define can_view_member : admin or member
      define can_add_resource : admin or member

```

You can define any numbers of roles for the organization type, and then define the permissions based on those roles. You can then check if users have a specific permission at the organization leve, by calling the Check API on the organization object: 

```
Check(user: "user:anne", relation: "can_add_member", object: "organization:acme") 
```

A better implementation is to define the application's resource types in the model (e.g. documents, projects, insurance policies, bank accounts, etc):


```
model 
  schema 1.1

  type user
  type organization
    relations
      define admin : [user]
      define member : [user]

      define can_add_member : admin
      define can_delete_member : admin
      define can_view_member : admin or member
      define can_add_resource : admin or member


   type resource
     relations
       define organization : [organization]

      # map resource permissions to organization roles
       define can_delete_resource : admin from organization or member from organization
       define can_view_resource : admin from organization or member from organization      

```

In this case, you'll need to write tuples that establish the relationship between resource instances and organizations, or use Contextual Tuples to specify them, e.g:

```
user: organization:acme
relation: organization
object: resource:root
```

In this case, the Check() call will be at the resource level, for example:

```
Check(user: "user:anne", relation: "can_view_resource", object: "resource:root") 
```

The main advantage of this approach is that your APIs will be checking permissions at the proper level. If you later ant to evolve your authorization model to be more fine grained, you won't need to change your app. For example, you can add fine grained access permissions at the resource level, and your authorization check won't change:

```
   type resource
     relations
       define organization : [organization]
       define owner: [user]
       define viewer : [user]

      # map resource permissions to organization roles
       define can_delete_resource : admin from organization or member from organization or owner
       define can_view_resource : admin from organization or member from organization or owner or viewer
```

## Provide request-level data

One of the advantages of the Zanzibar approach is that all the data you need to make authorization decisions is stored in a centralized database. That greatly simplifies how application implement access control. Applications do not need to retrieve al the required data before invoking an authorization service.

However, writing the data to the centralized store adds implementation complexity. You need to implement a data pipeline that makes sure the data is always up to date.

<ProductName format={ProductNameFormat.ShortForm}/> provides a feature called [Contextual Tuples](../interacting/contextual-tuples.mdx) that allows sending the required data as part of each authorization request, instead of storing it on the <ProductName format={ProductNameFormat.ShortForm}/> database. Of course, if you don't store any data in <ProductName format={ProductNameFormat.ShortForm}/> then you probably are using the wrong tool for the job, but implementing a hybrid approach can make sense in many scenarios.

When the data is already available to the calling API, sending it as a contextual tuple is very simple. A common use case is you have data in [your access tokens](../modeling/token-claims-contextual-tuples.mdx) (for example, roles/groups claims). Instead of synchronizing groups/roles relations to <ProductName format={ProductNameFormat.ShortForm}/>, you can send those as contextual tuples.

When the data is not already, you will need to retrieve it. This is what you need to do if you are implementing pure Attribute Access Control. You'd retrieve the data and send it to the authorization policy engine. You can do the same with <ProductName format={ProductNameFormat.ShortForm}/> using Contextual Tuples.

You'll need to make the trade-off between writing the data to <ProductName format={ProductNameFormat.ShortForm}/> so it's always available for any authorization request, or requesting it before making an authorization check.

We've seen companies sucessfully following an hybrid approach, starting by synchronizing the data that's easy first and provide the rest as contextual tuples. As their implementation matures, they implement more synchronization processes and stop sending the contextual tuples.

## Use <ProductName format={ProductNameFormat.ShortForm}/> to enrich JWTs

Once you have an <ProductName format={ProductNameFormat.ShortForm}/> model and data, you can start making authorization checks from your application. The preferred way is to perform a [Check()](../getting-started/perform-check.mdx) call.

However, you might have a large set of APIs that are already making authorization checks using JWTs. Changing those applications can be a significant investment. Even if JWTs have several drawbacks compared to making FGA API calls, it can be reasonable to first start by using <ProductName format={ProductNameFormat.ShortForm}/> to generate the claims that are stored in JWTs, while the applications keep using those claims to make authorization decisions.

Over time, you'll migrate the applications and APIs to use authorization check instead.

Authentication services usually provide a way to enrich access tokens during the authorization flow. You can see an example on how to do it with Auth0 [here](https://auth0.com/blog/adding-custom-claims-to-id-token-with-auth0-actions/).


For example, if you want to include in the access token the organizations that a user can log-in to, based on the following model:

```

  type user
  type organization
    relations
      define member : [user]
```

You can call ListObjects(type:"organization", relation:"member", user: "user:xxx") and include those.

## Promote Organization-Wide Adoption

To introduce <ProductName format={ProductNameFormat.ShortForm}/> in a large company, it's recommended that you identify a problem where the flexibility of <ProductName format={ProductNameFormat.ShortForm}/> enables quickly delivering business value to customers. It can be a new project, a new module, a new feature. Using <ProductName format={ProductNameFormat.ShortForm}/> for such a project can be an easier decision. Once an implementation is successful, you can try influencing the  influence the rest of the organization to adopt it.

A different approach is to try to convince your company to use <ProductName format={ProductNameFormat.ShortForm}/> as the new platform for Authorization for every project. 


\
Influencing the decision makers of a large organization to implement <ProductName format={ProductNameFormat.ShortForm}/>  is hard. 

Once a team has successfully deployed OpenFGA, it's simpler to make a case to extend it to other teams. 

Howeve each team has their own internal roadmaps and not all of the teams will see value on implementing OpenFGA, and a migration to OpenFGA can be seen as a tech-debt project instead of a business-value-driven one. 

--- Okta FGA

Okta FGA has a few features that simplify deploying FGA to multiple teams: multiple credentials, modules, per-module authorization (EXPAND)

--- OpenFGA FGA

OpenFGA has a few features that simplify deploying FGA to multiple teams: multiple credentials, access-control, etc.

Domain specific-rproxy

## Domain-Specific Proxy

Some adopters decide to wrap OpenFGA with their own authorization API. 

This can simplify FGA adoption by multiple teams, so they don't need to learn much about OpenFGA.

- Provide internal teams a domain-specific-API. Instead of writing a tuple saying 'user:x, viewer, document:y', they have a '/share-document' API. 

- Provide a single API for actions that require writing more than one tuple. Creating a new document in a folder requires 2 tuples. (TBD example)
- They can centralize calling external services to get additional dat aif they are providing contextual tuples
- Have a single service where they need to provide OpenFGA configuration data (store/model/credentials). This can be addressed with a secret management platform
- Can implement caching on their side

- for openFga: secure who an call FGA

Cons:
- Adds additional latency
- Additional complexity


## Authorization with Json Web Tokens vs OpenFGA

A lot has been written about the inconveniences of using JWTs for Authorization. They were originally designed for delegated access to 3rd party apps, but it was extended/abused for first-party permissions.

Besides the philosophical arguments, ther are 

JWTs:
- Pros
    - Do not require additional service roundtrips
    - Easier to implement
    - Standard, standard libraries

- Cons:
    - Token bloat, practical size limit
    - Corse grained
    - Not real-time
    - Role explosion

OpenFGA
- Pros
    - Fine grained
    - Real time

- Cons
    - Latency
    - Data Syncronization
