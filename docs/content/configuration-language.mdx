---
title: Configuration Language
sidebar_position: 2
slug: /configuration-language
---

import {
  AuthzModelSnippetViewer,
  DocumentationNotice,
  ProductConcept,
  ProductName,
  ProductNameFormat,
  RelatedSection,
  RelationshipTuplesViewer,
  SyntaxFormat,
  UpdateProductNameInLinks,
} from '@components/Docs';

# Configuration Language

<DocumentationNotice />

The <ProductName format={ProductNameFormat.LongForm}/>'s Configuration Language is used to build a representation of a system's _<ProductConcept section="what-is-an-authorization-model" linkName="authorization model" />_. It informs <UpdateProductNameInLinks link="/api/service" name="{ProductName}'s API" /> on what the <ProductConcept section="what-is-a-type" linkName="object types" /> in the system are and how they could relate to one another. It describes the <ProductConcept section="what-is-a-relation" linkName="relations" /> possible on an object of a certain type and lists the conditions under which one is related to that object.

The **DSL** and the **JSON** syntax are two presentations of that configuration language. The JSON syntax is accepted by the API and closely matches the API described in the [Zanzibar paper](https://research.google/pubs/pub48190/). The DSL is syntactic sugar on top of the JSON syntax and compiles down to it before being sent to <ProductName format={ProductNameFormat.ShortForm}/>'s API. The DSL is meant to make modeling easier and more intuitive.

You'll encounter the JSON syntax when calling the API directly or through the [SDKs](./getting-started), and the DSL when interacting with <ProductName format={ProductNameFormat.ShortForm}/> through the [Playground](https://play.fga.dev/). Throughout the documentation you can switch between the two presentations.

To understand this guide better, you should be familiar with some <ProductConcept /> and [How to get started on modeling](./modeling/getting-started.mdx).

## What Does The Configuration Language Look Like?

Below is a sample authorization model. In the next sections we'll go over the building blocks that make the <ProductName format={ProductNameFormat.ShortForm}/> configuration language.

<AuthzModelSnippetViewer
  configuration={{
    type_definitions: [
      {
        type: 'domain',
        relations: {
          member: {
            this: {},
          },
        },
      },
      {
        type: 'folder',
        relations: {
          can_share: {
            computedUserset: {
              object: '',
              relation: 'writer',
            },
          },
          owner: {
            union: {
              child: [
                {
                  this: {},
                },
                {
                  tupleToUserset: {
                    tupleset: {
                      object: '',
                      relation: 'parent_folder',
                    },
                    computedUserset: {
                      object: '',
                      relation: 'owner',
                    },
                  },
                },
              ],
            },
          },
          parent_folder: {
            this: {},
          },
          viewer: {
            union: {
              child: [
                {
                  this: {},
                },
                {
                  computedUserset: {
                    object: '',
                    relation: 'writer',
                  },
                },
                {
                  tupleToUserset: {
                    tupleset: {
                      object: '',
                      relation: 'parent_folder',
                    },
                    computedUserset: {
                      object: '',
                      relation: 'viewer',
                    },
                  },
                },
              ],
            },
          },
          writer: {
            union: {
              child: [
                {
                  this: {},
                },
                {
                  computedUserset: {
                    object: '',
                    relation: 'owner',
                  },
                },
                {
                  tupleToUserset: {
                    tupleset: {
                      object: '',
                      relation: 'parent_folder',
                    },
                    computedUserset: {
                      object: '',
                      relation: 'writer',
                    },
                  },
                },
              ],
            },
          },
        },
      },
      {
        type: 'document',
        relations: {
          can_share: {
            computedUserset: {
              object: '',
              relation: 'writer',
            },
          },
          owner: {
            union: {
              child: [
                {
                  this: {},
                },
                {
                  tupleToUserset: {
                    tupleset: {
                      object: '',
                      relation: 'parent_folder',
                    },
                    computedUserset: {
                      object: '',
                      relation: 'owner',
                    },
                  },
                },
              ],
            },
          },
          parent_folder: {
            this: {},
          },
          viewer: {
            union: {
              child: [
                {
                  this: {},
                },
                {
                  computedUserset: {
                    object: '',
                    relation: 'writer',
                  },
                },
                {
                  tupleToUserset: {
                    tupleset: {
                      object: '',
                      relation: 'parent_folder',
                    },
                    computedUserset: {
                      object: '',
                      relation: 'viewer',
                    },
                  },
                },
              ],
            },
          },
          writer: {
            union: {
              child: [
                {
                  this: {},
                },
                {
                  computedUserset: {
                    object: '',
                    relation: 'owner',
                  },
                },
                {
                  tupleToUserset: {
                    tupleset: {
                      object: '',
                      relation: 'parent_folder',
                    },
                    computedUserset: {
                      object: '',
                      relation: 'writer',
                    },
                  },
                },
              ],
            },
          },
        },
      },
    ],
  }}
/>

:::info

The _authorization model_ describes three _<ProductConcept section="what-is-a-type" linkName="types" />_ of objects: `domain`, `folder` and `document`.

The `domain` _<ProductConcept section="what-is-a-type-definition" linkName="type definition" />_ has a single _<ProductConcept section="what-is-a-relation" linkName="relation" />_ called `member` that only allows <ProductConcept section="what-are-direct-and-implied-relationships" linkName="direct relationships" />.

The `folder` and `document` _type definitions_ each have five _relations_: `parent_folder`, `owner`, `editor`, `viewer` and `can_share`.

:::

### The Direct Relationship Keyword

`self`, when used in the context of the <ProductConcept section="what-is-a-relation-definition" linkName="relation definition" /> allows <ProductConcept section="what-are-direct-and-implied-relationships" linkName="direct relationships" /> to the objects of this type. The absence of `self` disallows these direct relationships.

:::info

`self` in the <ProductName format={ProductNameFormat.ShortForm}/> DSL translates to `this` in the <ProductName format={ProductNameFormat.ShortForm}/> API syntax.

:::

For example, let's take a closer look at the `team` type.

<AuthzModelSnippetViewer
  configuration={{
    type: 'team',
    relations: {
      member: {
        this: {},
      },
    },
  }}
/>

This `team` _<ProductConcept section="what-is-a-type-definition" linkName="type definition" />_ defines all the _<ProductConcept section="what-is-a-relation" linkName="relations" />_ that _<ProductConcept section="what-is-a-user" linkName="users" />_ can have with an _<ProductConcept section="what-is-an-object" linkName="object" />_ of _type_ `team`. In this case the _relation_ is: `member`.

Due to the direct relationship keyword (`self`) being used, a user in the system can have a **<ProductConcept section="what-are-direct-and-implied-relationships" linkName="direct relationship" />** with the `team` type as a `member`.

In the type definition snippet above, `anne` is a `member` of `team:product` if _any one of_ the following relationship tuple sets exist:

- <RelationshipTuplesViewer
    relationshipTuples={[
      {
        user: 'anne',
        relation: 'member',
        object: 'team:product',
        _description: 'Anne is directly related to the product team as a member',
      },
    ]}
  />

- <RelationshipTuplesViewer
    relationshipTuples={[
      {
        user: '*',
        relation: 'member',
        object: 'team:product',
        _description: 'Everyone (`*`) is directly related to the product team as a member',
      },
    ]}
  />

- <RelationshipTuplesViewer
    relationshipTuples={[
      {
        user: 'team:contoso#member',
        relation: 'member',
        object: 'team:product',
        _description: 'Members of the contoso team are members of the product team',
      },
      {
        user: 'anne',
        relation: 'member',
        object: 'team:contoso',
        _description: 'Anne is a member of the contoso team',
      },
    ]}
  />

For more examples, take look at [Modeling Building Blocks: Direct Relationships](./modeling/building-blocks/direct-relationships.mdx).

### Referencing Other Relations On The Same Object

You can also reference other relations on the same object. Let us look at a simplified `document` _type definition_.

<AuthzModelSnippetViewer
  configuration={{
    type: 'document',
    relations: {
      editor: {
        this: {},
      },
      viewer: {
        union: {
          child: [
            { this: {} },
            {
              computedUserset: {
                relation: 'editor',
              },
            },
          ],
        },
      },
      can_rename: {
        computedUserset: {
          relation: 'editor',
        },
      },
    },
  }}
/>

The above `document` _<ProductConcept section="what-is-a-type-definition" linkName="type definition" />_ defines all the _<ProductConcept section="what-is-a-relation" linkName="relations" />_ that _<ProductConcept section="what-is-a-user" linkName="users" />_ can have with an _<ProductConcept section="what-is-an-object" linkName="object" />_ of _type_ `document`. In this case the _relations_ are: `editor`, `viewer` and `can_rename`.

The `viewer` and `can_rename` _relation definitions_ are both referencing `editor`, which is another relation on the same type.

:::info

Notice how `can_rename` does not reference the [_direct relationship keyword_](#the-direct-relationship-keyword) (`self`), indicating that a direct relationship is not possible (as in a user cannot be directly assigned this relation, it has to be inherited through an assignment of the `editor` relation). The `viewer` relation on the other hand allows both _direct and indirect relationships_ using the [Union Operator](#the-union-operator).

:::

In the _type definition_ snippet above, `anne` is a `viewer` of `document:new-roadmap` if any one of the following relationship tuple sets exists:

- _anne_ is an _editor_ of _document:new-roadmap_

  <RelationshipTuplesViewer
    relationshipTuples={[
      {
        user: 'anne',
        relation: 'editor',
        object: 'document:new-roadmap',
        _description: 'Anne is an editor of the new-roadmap document',
      },
    ]}
  />

- _anne_ is a _viewer_ of _document:new-roadmap_
  <RelationshipTuplesViewer
    relationshipTuples={[
      {
        user: 'anne',
        relation: 'viewer',
        object: 'document:new-roadmap',
        _description: 'Anne is a viewer of the new-roadmap document',
      },
    ]}
  />

`anne` has a `can_rename` relationship with `document:new-roadmap` only if `anne` has an `editor` relationship with the document:

- _anne_ is an _editor_ of _document:new-roadmap_
  <RelationshipTuplesViewer
    relationshipTuples={[
      {
        user: 'anne',
        relation: 'editor',
        object: 'document:new-roadmap',
        _description: 'Anne is an editor of thew new-roadmap document',
      },
    ]}
  />

For more examples, take a look at [Modeling Building Blocks: Concentric Relationships](./modeling/building-blocks/concentric-relationships.mdx), [Modeling: Roles and Permissions](./modeling/roles-and-permissions.mdx) and [Advanced Modeling: Google Drive](./modeling/advanced/gdrive.mdx).

### Referencing Relations On Related Objects

Another form of _<ProductConcept section="what-are-direct-and-implied-relationships" linkName="indirect relationships" />_ is made possible by referencing relations on other objects.

The syntax is `X from Y`.
It requires that:

- the other object is related to the current object as `Y`
- the _user_ is related to another object as `X`

Take a look at the _authorization model_ below.

<AuthzModelSnippetViewer
  configuration={{
    type_definitions: [
      {
        type: 'folder',
        relations: {
          viewer: {
            this: {},
          },
        },
      },
      {
        type: 'document',
        relations: {
          parent_folder: {
            this: {},
          },
          viewer: {
            union: {
              child: [
                { this: {} },
                {
                  tupleToUserset: {
                    tupleset: {
                      object: '',
                      relation: 'parent_folder',
                    },
                    computedUserset: {
                      object: '',
                      relation: 'viewer',
                    },
                  },
                },
              ],
            },
          },
        },
      },
    ],
  }}
/>

The snippet below taken from the authorization model above is stating that viewers of a document are all users directly assigned the viewer relation and all users who can view the document's parent folder.

<AuthzModelSnippetViewer
  configuration={{
    viewer: {
      union: {
        child: [
          { this: {} },
          {
            tupleToUserset: {
              tupleset: {
                object: '',
                relation: 'parent_folder',
              },
              computedUserset: {
                object: '',
                relation: 'viewer',
              },
            },
          },
        ],
      },
    },
  }}
/>

In the _authorization model_ above, `anne` is a `viewer` of `document:new-roadmap` if any one of the following relationship tuple sets exists:

- Anne is a viewer of the parent folder of the new-roadmap document
  <RelationshipTuplesViewer
    relationshipTuples={[
      {
        user: 'folder:planning',
        relation: 'parent_folder',
        object: 'document:new-roadmap',
        _description: 'planning folder is the parent folder of the new-roadmap document',
      },
      {
        user: 'anne',
        relation: 'viewer',
        object: 'folder:planning',
        _description: 'anne is a viewer of the planning folder',
      },
    ]}
  />
- Anne is a viewer of the new-roadmap document (direct relationship)
  <RelationshipTuplesViewer
    relationshipTuples={[
      {
        user: 'anne',
        relation: 'viewer',
        object: 'document:new-roadmap',
        _description: 'anne is a viewer of the new-roadmap document',
      },
    ]}
  />

This particular use of referencing relations on related objects is defining a transitive implied relationship. If **user A** is related to a certain **object B** as a **viewer**, and **object B** is related to **object C** as **parent**, then **user A** is related to **object C** as **viewer**.

This can be used to indicate that **viewers** of a **folders** are **viewers** of all **documents** in that **folder**.

For more examples, take look at [Modeling: Parent-Child Objects](./modeling/parent-child.mdx), [Advanced Modeling: Google Drive](./modeling/advanced/gdrive.mdx), [Advanced Modeling: GitHub](./modeling/advanced/github.mdx), and [Advanced Modeling: Entitlements](./modeling/advanced/entitlements.mdx).

### The Union Operator

The _union operator_ (`or` in the DSL, `union` in the JSON syntax) is used to indicate that a <ProductConcept section="what-is-a-relationship" linkName="relationship" /> exists if the <ProductConcept section="what-is-a-user" linkName="user" /> is in **any of the sets of users** (`union`).

<AuthzModelSnippetViewer
  configuration={{
    viewer: {
      // a user is related to the object as a viewer if:
      union: {
        // they are in any of
        child: [
          {
            this: {}, // the userset of all users related to the object as "viewer"; indicating that a user can be assigned a direct `viewer` relation, i.e., not implied through another relation
          },
          {
            computedUserset: {
              relation: 'editor', // the userset of all users related to the object as "editor"; indicating that a user who is an editor is also implicitly a viewer
            },
          },
        ],
      },
    },
  }}
/>

In the <ProductConcept section="what-is-a-type-definition" linkName="type definition" /> snippet above, `anne` is a `viewer` of `document:new-roadmap` if _any of_ the following conditions are satisfied:

- there exists a <ProductConcept section="what-are-direct-and-implied-relationships" linkName="direct relationship" /> with _anne_ as _editor_ of _document:new-roadmap_
  <RelationshipTuplesViewer
    relationshipTuples={[
      {
        user: 'anne',
        relation: 'editor',
        object: 'document:new-roadmap',
      },
    ]}
  />
- _anne_ is a _viewer_ of _document:new-roadmap_:
  <RelationshipTuplesViewer
    relationshipTuples={[
      {
        user: 'anne',
        relation: 'viewer',
        object: 'document:new-roadmap',
      },
    ]}
  />

:::info

The above <ProductConcept section="what-is-an-authorization-model" linkName="authorization model" /> indicates that a user is related as a viewer if they are in **any of**:

- the userset of all users related to the object as "viewer"; indicating that a user can be assigned a direct `viewer` relation
- the userset of all users related to the object as "editor"; indicating that a user who is an editor is also implicitly a viewer

So if **anne** is in at least one of those usersets (is either an **editor** or a **viewer**), the <ProductConcept section="what-is-a-check-request" linkName="check" /> on `{"user": "anne", "relation": "viewer", "object": "document:new-roadmap"}` will return `{"allowed": true}`.

:::

For more examples, take a look at [Modeling Building Blocks: Concentric Relationships](./modeling/building-blocks/concentric-relationships.mdx), [Modeling Roles and Permissions](./modeling/roles-and-permissions.mdx) and [Advanced Modeling: Modeling for IoT](./modeling/advanced/iot.mdx#03-updating-our-authorization-model-to-facilitate-future-changes).

### The Intersection Operator

The _intersection operator_ (`and` in the DSL, `intersection` in the JSON syntax) is used to indicate that a <ProductConcept section="what-is-a-relationship" linkName="relationship" /> exists if the <ProductConcept section="what-is-a-user" linkName="user" /> is in **all the sets of users** (`intersection`)

<AuthzModelSnippetViewer
  configuration={{
    viewer: {
      // a user is related to the object as a viewer if
      intersection: {
        // they are in all of
        child: [
          {
            computedUserset: {
              // the userset of all users related to the object as "authorized_user"
              relation: 'authorized_user',
            },
          },
          {
            computedUserset: {
              // the userset of all users related to the object as "editor"
              relation: 'editor',
            },
          },
        ],
      },
    },
  }}
/>

In the <ProductConcept section="what-is-a-type-definition" linkName="type definition" /> snippet above, `anne` is a `viewer` of `document:new-roadmap` if **all of** the following conditions are satisfied:

- _anne_ is an _editor_ of _document:new-roadmap_
  <RelationshipTuplesViewer
    relationshipTuples={[
      {
        user: 'anne',
        relation: 'editor',
        object: 'document:new-roadmap',
      },
    ]}
  />
  AND
- _anne_ is an _authorized_user_ of _document:new-roadmap_:
  <RelationshipTuplesViewer
    relationshipTuples={[
      {
        user: 'anne',
        relation: 'authorized_user',
        object: 'document:new-roadmap',
      },
    ]}
  />

:::info

The above <ProductConcept section="what-is-an-authorization-model" linkName="authorization model" /> indicates that a user is related as a viewer if they are in **all of**:

- the userset of all users related to the object as "authorized_user"
- the userset of all users related to the object as "editor"

So **anne** has to be in the intersection of the usersets (**anne** has to be both an **editor** AND an **authorized_user**), in order for the <ProductConcept section="what-is-a-check-request" linkName="check" /> on `{"user": "anne", "relation": "viewer", "object": "document:new-roadmap"}` to return `{"allowed": true}`.

_anne_ is **not** a _viewer_ for _document:new-roadmap_ if either of the following is true:

- _anne_ is not an _editor_ to _document:new-roadmap_: **no relationship tuple of** `{"user": "anne", "relation": "editor", "object": "document:new-roadmap"}`
- _anne_ is not an _authorized_user_ on the _document:new-roadmap_: **no relationship tuple of** `{"user": "anne", "relation": "authorized_user", "object": "document:new-roadmap"}`

:::

For more examples, take look at [Modeling with Multiple Restrictions](./modeling/multiple-restrictions.mdx).

### The Exclusion Operator

The _exclusion operator_ (`but not` in the DSL, `difference` in the JSON syntax) is used to indicate that a <ProductConcept section="what-is-a-relationship" linkName="relationship" /> exists if the <ProductConcept section="what-is-a-user" linkName="user" /> is **in the base userset, but not in the excluded userset**. This is helpful in modeling exclusion or block lists.

<AuthzModelSnippetViewer
  configuration={{
    viewer: {
      // a user is related to the object as a viewer if they are in
      difference: {
        base: {
          this: {}, // the userset of all users related to the object as "viewer"
        },
        subtract: {
          computedUserset: {
            relation: 'blocked', // but not in the userset of all users related to the object as "blocked"
          },
        },
      },
    },
  }}
/>

In the _type definition_ snippet above, `anne` is a `viewer` of `document:new-roadmap` if:

- _anne_ is assigned a direct relationship as _viewer_ to _document:new-roadmap_

  <RelationshipTuplesViewer
    relationshipTuples={[
      {
        user: 'anne',
        relation: 'viewer',
        object: 'document:new-roadmap',
      },
    ]}
  />
  AND

- _anne_ is not _blocked_ to _document:new-roadmap_. That is, the following relation tuple **does not exists**
  <RelationshipTuplesViewer
    relationshipTuples={[
      {
        user: 'anne',
        relation: 'blocked',
        object: 'document:new-roadmap',
      },
    ]}
  />

For more information, see [Modeling: Blocklists](./modeling/blocklists.mdx).

:::info

The above <ProductConcept section="what-is-an-authorization-model" linkName="authorization model" /> indicates that a user is related as a viewer if they are in:

- the userset of all users related to the object as "viewer"

but not in:

- the userset of all users related to the object as "blocked"

So **anne** has to be both a **viewer** AND NOT **blocked**, in order for the <ProductConcept section="what-is-a-check-request" linkName="check" /> on `{"user": "anne", "relation": "viewer", "object": "document:new-roadmap"}` to return `{"allowed": true}`.

_anne_ is **not** a _viewer_ for _document:new-roadmap_ if either of the following is true:

- _anne_ is **not** assigned direct relationship as _viewer_ to _document:new-roadmap_: **no relationship tuple of** `{"user": "anne", "relation": "viewer", "object": "document:new-roadmap"}`
- _anne_ is _blocked_ on the _document:new-roadmap_ `{"user": "anne", "relation": "blocked", "object": "document:new-roadmap"}`

:::

## Equivalent Zanzibar Concepts

The JSON syntax accepted by the <ProductName format={ProductNameFormat.ShortForm}/> API closely mirrors the syntax represented in the Zanzibar paper, with a bit of flattening and converting keys from `snake_case` to `camelCase`.

| Zanzibar           | <ProductName format={ProductNameFormat.ShortForm}/> JSON | <ProductName format={ProductNameFormat.ShortForm}/> DSL |
| :----------------- | :------------------------------------------------------- | :------------------------------------------------------ |
| `this`             | `this`                                                   | `self`                                                  |
| `union`            | `union`                                                  | `or`                                                    |
| `intersection`     | `intersection`                                           | `and`                                                   |
| `exclusion`        | `difference`                                             | `but not`                                               |
| `tuple_to_userset` | `tupleToUserset`                                         | `x from y`                                              |

In the [Zanzibar paper](https://research.google/pubs/pub48190/), there's this example:

```
name: "doc"

relation { name: "owner" }

relation {
  name: "editor"
  userset_rewrite {
    union {
      child { _this {} }
      child { computed_userset { relation: "owner" } }
}}}

relation {
 name: "viewer"
 userset_rewrite {
  union {
    child { _this {} }
    child { computed_userset { relation: "editor" } }
    child { tuple_to_userset {
      tupleset { relation: "parent" }
      computed_userset {
        object: $TUPLE_USERSET_OBJECT  # parent folder
        relation: "viewer" }}}
}}}
```

In the <ProductName format={ProductNameFormat.ShortForm}/> DSL, it would become:

<AuthzModelSnippetViewer
  onlyShow={SyntaxFormat.Friendly2}
  configuration={{
    type_definitions: [
      {
        type: 'doc',
        relations: {
          owner: {
            this: {},
          },
          editor: {
            union: {
              child: [
                {
                  this: {},
                },
                {
                  computedUserset: {
                    relation: 'owner',
                  },
                },
              ],
            },
          },
          viewer: {
            union: {
              child: [
                {
                  this: {},
                },
                {
                  computedUserset: {
                    relation: 'editor',
                  },
                },
                {
                  tupleToUserset: {
                    tupleset: {
                      relation: 'parent',
                    },
                    computedUserset: {
                      relation: 'viewer',
                    },
                  },
                },
              ],
            },
          },
        },
      },
    ],
  }}
/>

And in the <ProductName format={ProductNameFormat.ShortForm}/> JSON, it would become:

<AuthzModelSnippetViewer
  onlyShow={SyntaxFormat.Api}
  configuration={{
    type_definitions: [
      {
        type: 'doc',
        relations: {
          owner: {
            this: {},
          },
          editor: {
            union: {
              child: [
                {
                  this: {},
                },
                {
                  computedUserset: {
                    relation: 'owner',
                  },
                },
              ],
            },
          },
          viewer: {
            union: {
              child: [
                {
                  this: {},
                },
                {
                  computedUserset: {
                    relation: 'editor',
                  },
                },
                {
                  tupleToUserset: {
                    tupleset: {
                      relation: 'parent',
                    },
                    computedUserset: {
                      relation: 'viewer',
                    },
                  },
                },
              ],
            },
          },
        },
      },
    ],
  }}
/>

We believe this syntax is easier to read/write.

So the following:

<AuthzModelSnippetViewer
  configuration={{
    viewer: {
      union: {
        child: [
          {
            // a user can be assigned a direct `viewer` relation, i.e., not implied through another relation
            this: {},
          },
          {
            // a user that is an editor is also implicitly a viewer
            computedUserset: {
              relation: 'editor',
            },
          },
          {
            // a user that is an viewer on any of the object's parents is also implicitly a viewer on the object
            tupleToUserset: {
              tupleset: {
                relation: 'parent',
              },
              computedUserset: {
                relation: 'viewer',
              },
            },
          },
        ],
      },
    },
  }}
/>

Can be read as:

- The users with a viewer relationship to a certain doc are any of:
  - the set of users who are <ProductConcept section="what-are-direct-and-implied-relationships" linkName="directly related" /> with this doc as `viewer`
  - the set of users who are related to this doc as `editor`
  - the set of users who are related to any object OBJ_1 as `viewer`, where object OBJ_1 is any object related to this doc as `parent` (e.g. viewers of this doc's parent folder, where the parent folder is OBJ_1)

Learn more about Zanzibar at the [Zanzibar Academy](https://zanzibar.academy).

## Related Sections

<RelatedSection
  description="Check the following sections for more on how to use the configuration language in modeling authorization."
  relatedLinks={[
    {
      title: '{ProductName} Concepts',
      description: 'Learn about the {ProductName} Concepts.',
      link: './concepts',
      id: './concepts',
    },
    {
      title: 'Modeling: Getting Started',
      description: 'Learn about how to get started with modeling your permission system in {ProductName}.',
      link: './modeling/getting-started',
      id: './modeling/getting-started',
    },
    {
      title: 'Direct Access',
      description: 'Learn about modeling user access to an object.',
      link: './modeling/direct-access',
      id: './modeling/direct-access',
    },
  ]}
/>
