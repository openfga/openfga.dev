---
title: Configuration Language
sidebar_position: 2
slug: /configuration-language
description: Learning about the FGA configuration language and using it to build a representation of a system's authorization model
---

import {
  AuthzModelSnippetViewer,
  CheckRequestViewer,
  DocumentationNotice,
  ProductConcept,
  ProductName,
  ProductNameFormat,
  RelatedSection,
  RelationshipTuplesViewer,
  SyntaxFormat,
  UpdateProductNameInLinks,
  WriteRequestViewer,
} from '@components/Docs';

# Configuration Language

<DocumentationNotice />

<ProductName format={ProductNameFormat.LongForm}/>'s Configuration Language builds a representation of a system's <ProductConcept section="what-is-an-authorization-model" linkName="authorization model" />, which informs <UpdateProductNameInLinks link="/api/service" name="{ProductName}'s API" /> on the <ProductConcept section="what-is-a-type" linkName="object types" /> in the system are and how they relate to each other. The Configuration Language describes the <ProductConcept section="what-is-a-relation" linkName="relations" /> possible for an object of a given type and lists the conditions under which one is related to that object.

The Configuration Language can be presented in **DSL** or **JSON** syntax. The JSON syntax is accepted by the API and closely tracks the language in the [Zanzibar paper](https://research.google/pubs/pub48190/). The DSL adds syntactic sugar on top of JSON for ease of use, but compiles down to JSON before being sent to <ProductName format={ProductNameFormat.ShortForm}/>'s API. JSON syntax is used to call API directly or through the [SDKs](./getting-started), while DSL is used to interact with <ProductName format={ProductNameFormat.ShortForm}/> in the [Playground](https://play.fga.dev/), and they can be switched between throughout this documentation. 

Please familiarize yourself with basic <ProductConcept /> and [How to get started on modeling](./modeling/getting-started.mdx) before starting this guide.

## What Does The Configuration Language Look Like?

Below is a sample authorization model. The next sections discuss the basics of the <ProductName format={ProductNameFormat.ShortForm}/> configuration language.

<AuthzModelSnippetViewer
  configuration={{
    schema_version: '1.1',
    type_definitions: [
      {
        type: 'user',
      },
      {
        type: 'domain',
        relations: {
          member: {
            this: {},
          },
        },
        metadata: {
          relations: {
            member: { directly_related_user_types: [{ type: 'user' }] },
          },
        },
      },
      {
        type: 'folder',
        relations: {
          can_share: {
            computedUserset: {
              object: '',
              relation: 'writer',
            },
          },
          owner: {
            union: {
              child: [
                {
                  this: {},
                },
                {
                  tupleToUserset: {
                    tupleset: {
                      object: '',
                      relation: 'parent_folder',
                    },
                    computedUserset: {
                      object: '',
                      relation: 'owner',
                    },
                  },
                },
              ],
            },
          },
          parent_folder: {
            this: {},
          },
          viewer: {
            union: {
              child: [
                {
                  this: {},
                },
                {
                  computedUserset: {
                    object: '',
                    relation: 'writer',
                  },
                },
                {
                  tupleToUserset: {
                    tupleset: {
                      object: '',
                      relation: 'parent_folder',
                    },
                    computedUserset: {
                      object: '',
                      relation: 'viewer',
                    },
                  },
                },
              ],
            },
          },
          writer: {
            union: {
              child: [
                {
                  this: {},
                },
                {
                  computedUserset: {
                    object: '',
                    relation: 'owner',
                  },
                },
                {
                  tupleToUserset: {
                    tupleset: {
                      object: '',
                      relation: 'parent_folder',
                    },
                    computedUserset: {
                      object: '',
                      relation: 'writer',
                    },
                  },
                },
              ],
            },
          },
        },
        metadata: {
          relations: {
            owner: { directly_related_user_types: [{ type: 'user' }, { type: 'domain', relation: 'member' }] },
            parent_folder: { directly_related_user_types: [{ type: 'folder' }] },
            viewer: { directly_related_user_types: [{ type: 'user' }, { type: 'domain', relation: 'member' }] },
            writer: { directly_related_user_types: [{ type: 'user' }, { type: 'domain', relation: 'member' }] },
          },
        },
      },
      {
        type: 'document',
        relations: {
          can_share: {
            computedUserset: {
              object: '',
              relation: 'writer',
            },
          },
          owner: {
            union: {
              child: [
                {
                  this: {},
                },
                {
                  tupleToUserset: {
                    tupleset: {
                      object: '',
                      relation: 'parent_folder',
                    },
                    computedUserset: {
                      object: '',
                      relation: 'owner',
                    },
                  },
                },
              ],
            },
          },
          parent_folder: {
            this: {},
          },
          viewer: {
            union: {
              child: [
                {
                  this: {},
                },
                {
                  computedUserset: {
                    object: '',
                    relation: 'writer',
                  },
                },
                {
                  tupleToUserset: {
                    tupleset: {
                      object: '',
                      relation: 'parent_folder',
                    },
                    computedUserset: {
                      object: '',
                      relation: 'viewer',
                    },
                  },
                },
              ],
            },
          },
          writer: {
            union: {
              child: [
                {
                  this: {},
                },
                {
                  computedUserset: {
                    object: '',
                    relation: 'owner',
                  },
                },
                {
                  tupleToUserset: {
                    tupleset: {
                      object: '',
                      relation: 'parent_folder',
                    },
                    computedUserset: {
                      object: '',
                      relation: 'writer',
                    },
                  },
                },
              ],
            },
          },
        },
        metadata: {
          relations: {
            owner: { directly_related_user_types: [{ type: 'user' }, { type: 'domain', relation: 'member' }] },
            parent_folder: { directly_related_user_types: [{ type: 'folder' }] },
            viewer: { directly_related_user_types: [{ type: 'user' }, { type: 'domain', relation: 'member' }] },
            writer: { directly_related_user_types: [{ type: 'user' }, { type: 'domain', relation: 'member' }] },
          },
        },
      },
    ],
  }}
/>

:::info

The authorization model describes four <ProductConcept section="what-is-a-type" linkName="types" /> of objects: `user`, `domain`, `folder` and `document`.

The `domain` <ProductConcept section="what-is-a-type-definition" linkName="type definition" /> has a single <ProductConcept section="what-is-a-relation" linkName="relation" /> called `member` that only allows <ProductConcept section="what-are-direct-and-implied-relationships" linkName="direct relationships" />.

The `folder` and `document` type definitions each have five relations: `parent_folder`, `owner`, `writer`, `viewer` and `can_share`.

:::

### Direct Relationship Type Restrictions

When used at the beginning of a <ProductConcept section="what-is-a-relation-definition" linkName="relation definition" />, `[<string, <string>, ...]` allows <ProductConcept section="what-are-direct-and-implied-relationships" linkName="direct relationships" /> by the objects of these specified types. The strings can be in one of three formats:
- `<type>`: indicates that tuples relating objects of those types as users can be written. For example, `group:marketing` can be related if `group` is in the type restrictions.
- `<type:*>`: indicates that a tuple relating all objects of that type can be written. For example, `user:*` can be added if `user:*` is in the type restrictions.
- `<type>#<relation>`: indicates tuples with sets of users related to an object of that type by that particular relation. For example, `group:marketing#member` can be added if `group#member` is in the type restrictions.

If no direct relationship type restrictions are specified, direct relationships are disallowed and tuples cannot be written relating other objects of this particular relation with objects of this type.

:::info

`[<type1>, <type2>, ...]` in the <ProductName format={ProductNameFormat.ShortForm}/> DSL translates to `this` in the <ProductName format={ProductNameFormat.ShortForm}/> API syntax.

:::

For example, below is a snippet of the `team` type:

<AuthzModelSnippetViewer
  configuration={{
    schema_version: '1.1',
    type: 'team',
    relations: {
      member: {
        this: {},
      },
    },
    metadata: {
      relations: {
        member: { directly_related_user_types: [{ type: 'user' }, { type: 'user:*'}, { type: 'team', relation: 'member' }] },
      },
    },
  }} skipVersion={true}
/>

The `team` <ProductConcept section="what-is-a-type-definition" linkName="type definition" /> above defines all the <ProductConcept section="what-is-a-relation" linkName="relations" /> that <ProductConcept section="what-is-a-user" linkName="users" /> can have with an _<ProductConcept section="what-is-an-object" linkName="object" />_ of type `team`. In this example, the relation is `member`.

Because of the `[user, team#member]` direct relationship type restrictions used, a user in the system can have a **<ProductConcept section="what-are-direct-and-implied-relationships" linkName="direct relationship" />** with the `team` type as a `member` for objects of: 
- type `user`
- the `user` <ProductConcept section="what-is-type-bound-public-access" linkName="type bound public access" /> (`user:*`)
- [usersets](./modeling/building-blocks/usersets.mdx) that have a `team` type and a `member` relation (e.g. `team:product#member`)

In the type definition snippet above, `anne` is a `member` of `team:product` if any of the following relationship tuple sets exist:

- <RelationshipTuplesViewer
    relationshipTuples={[
      {
        user: 'user:anne',
        relation: 'member',
        object: 'team:product',
        _description: 'Anne is directly related to the product team as a member',
      },
    ]}
  />

- <RelationshipTuplesViewer
    relationshipTuples={[
      {
        user: 'user:*',
        relation: 'member',
        object: 'team:product',
        _description: 'Everyone (`*`) is directly related to the product team as a member',
      },
    ]}
  />

- <RelationshipTuplesViewer
    relationshipTuples={[
      {
        user: 'team:contoso#member',
        relation: 'member',
        object: 'team:product',
        _description: 'Members of the contoso team are members of the product team',
      },
      {
        user: 'user:anne',
        relation: 'member',
        object: 'team:contoso',
        _description: 'Anne is a member of the contoso team',
      },
    ]}
  />

For more examples, see [Modeling Building Blocks: Direct Relationships](./modeling/building-blocks/direct-relationships.mdx).

### Referencing Other Relations On The Same Object

The same object can also reference other relations. Below is a simplified `document` type definition:

<AuthzModelSnippetViewer
  configuration={{
    schema_version: '1.1',
    type: 'document',
    relations: {
      editor: {
        this: {},
      },
      viewer: {
        union: {
          child: [
            { this: {} },
            {
              computedUserset: {
                relation: 'editor',
              },
            },
          ],
        },
      },
      can_rename: {
        computedUserset: {
          relation: 'editor',
        },
      },
    },
    metadata: {
      relations: {
        editor: { directly_related_user_types: [{ type: 'user' }] },
        viewer: { directly_related_user_types: [{ type: 'user' }] },
      },
    },
  }} skipVersion={true}
/>

Above, `document` <ProductConcept section="what-is-a-type-definition" linkName="type definition" /> defines all the <ProductConcept section="what-is-a-relation" linkName="relations" /> that <ProductConcept section="what-is-a-user" linkName="users" /> can have with an <ProductConcept section="what-is-an-object" linkName="object" /> of type `document`. In this case, the relations are `editor`, `viewer` and `can_rename`. The `viewer` and `can_rename` relation definitions both reference `editor`, which is another relation of the same type.

:::info

`can_rename` does not reference the [direct relationship type restrictions](#the-direct-relationship-type-restrictions), which means a user cannot be directly assigned this relation and it must inherited when the `editor` relation is assigned. Conversely, the `viewer` relation allows both direct and indirect relationships using the [Union Operator](#the-union-operator).

:::

In the type definition snippet above, `anne` is a `viewer` of `document:new-roadmap` if any one of the following relationship tuple sets exists:

- _anne_ is an _editor_ of _document:new-roadmap_

  <RelationshipTuplesViewer
    relationshipTuples={[
      {
        user: 'user:anne',
        relation: 'editor',
        object: 'document:new-roadmap',
        _description: 'Anne is an editor of the new-roadmap document',
      },
    ]}
  />

- _anne_ is a _viewer_ of _document:new-roadmap_
  <RelationshipTuplesViewer
    relationshipTuples={[
      {
        user: 'user:anne',
        relation: 'viewer',
        object: 'document:new-roadmap',
        _description: 'Anne is a viewer of the new-roadmap document',
      },
    ]}
  />

`anne` has a `can_rename` relationship with `document:new-roadmap` only if `anne` has an `editor` relationship with the document:

- _anne_ is an _editor_ of _document:new-roadmap_
  <RelationshipTuplesViewer
    relationshipTuples={[
      {
        user: 'user:anne',
        relation: 'editor',
        object: 'document:new-roadmap',
        _description: 'Anne is an editor of thew new-roadmap document',
      },
    ]}
  />

For more examples, see [Modeling Building Blocks: Concentric Relationships](./modeling/building-blocks/concentric-relationships.mdx), [Modeling: Roles and Permissions](./modeling/roles-and-permissions.mdx) and [Advanced Modeling: Google Drive](./modeling/advanced/gdrive.mdx).

### Referencing Relations On Related Objects

Another set of <ProductConcept section="what-are-direct-and-implied-relationships" linkName="indirect relationships" /> are made possible by referencing relations to other objects.

The syntax is `X from Y` and requires that:

- the other object is related to the current object as `Y`
- the _user_ is related to another object as `X`

See the _authorization model_ below.

<AuthzModelSnippetViewer
  configuration={{
    schema_version: '1.1',
    type_definitions: [
      {
        type: 'user',
      },
      {
        type: 'folder',
        relations: {
          viewer: {
            this: {},
          },
        },
        metadata: {
          relations: {
            viewer: { directly_related_user_types: [{ type: 'user' }, { type: 'folder', relation: 'viewer' }] },
          },
        },
      },
      {
        type: 'document',
        relations: {
          parent_folder: {
            this: {},
          },
          viewer: {
            union: {
              child: [
                { this: {} },
                {
                  tupleToUserset: {
                    tupleset: {
                      object: '',
                      relation: 'parent_folder',
                    },
                    computedUserset: {
                      object: '',
                      relation: 'viewer',
                    },
                  },
                },
              ],
            },
          },
        },
        metadata: {
          relations: {
            parent_folder: { directly_related_user_types: [{ type: 'folder' }] },
            viewer: { directly_related_user_types: [{ type: 'user' }] },
          },
        },
      },
    ],
  }}
/>

The snippet below (taken from the authorization model above) states that viewers of a document are both (a) all users directly assigned the viewer relation and (b) all users who can view the document's parent folder.

<AuthzModelSnippetViewer
  configuration={{
    schema_version: '1.1',
    type_definitions: [
      {
        type: 'document',
        relations: {
          viewer: {
            union: {
              child: [
                { this: {} },
                {
                  tupleToUserset: {
                    tupleset: {
                      object: '',
                      relation: 'parent_folder',
                    },
                    computedUserset: {
                      object: '',
                      relation: 'viewer',
                    },
                  },
                },
              ],
            },
          },
        },
        metadata: {
          relations: {
            viewer: { directly_related_user_types: [{ type: 'user' }] },
          },
        },
      },
    ],
  }} skipVersion={true}
/>

In the authorization model above, `user:anne` is a `viewer` of `document:new-roadmap` if any one of the following relationship tuples sets exists:

- Anne is a viewer of the parent folder of the new-roadmap document
  <RelationshipTuplesViewer
    relationshipTuples={[
      {
        user: 'folder:planning',
        relation: 'parent_folder',
        object: 'document:new-roadmap',
        _description: 'planning folder is the parent folder of the new-roadmap document',
      },
      {
        user: 'user:anne',
        relation: 'viewer',
        object: 'folder:planning',
        _description: 'anne is a viewer of the planning folder',
      },
    ]}
  />
- Anne is a viewer of the new-roadmap document (direct relationship)
  <RelationshipTuplesViewer
    relationshipTuples={[
      {
        user: 'user:anne',
        relation: 'viewer',
        object: 'document:new-roadmap',
        _description: 'anne is a viewer of the new-roadmap document',
      },
    ]}
  />

Referencing relations on related objects defines transitive implied relationship. If User A is related to Object B as a viewer, and Object B is related to Object C as parent, then User A is related to Object C as viewer. This can indicate that viewers of a folders are viewers of all documents in that folder.

:::caution
<ProductName format={ProductNameFormat.LongForm}/> does not allow the referenced relation (the word after `from`, also called the tupleset) to reference another relation and does not allow non-concrete types (type bound public access (`<object_type>:*`) or usersets (`<object_type>#<relation>`)) in its type restrictions; adding them throws a validation error when calling `WriteAuthorizationModel`.
:::

For more examples, see [Modeling: Parent-Child Objects](./modeling/parent-child.mdx), [Advanced Modeling: Google Drive](./modeling/advanced/gdrive.mdx), [Advanced Modeling: GitHub](./modeling/advanced/github.mdx), and [Advanced Modeling: Entitlements](./modeling/advanced/entitlements.mdx).

### The Union Operator

The **union operator** (`or` in the DSL, `union` in the JSON syntax) indicates that a <ProductConcept section="what-is-a-relationship" linkName="relationship" /> exists if the <ProductConcept section="what-is-a-user" linkName="user" /> is in any of the sets of users (`union`).

<AuthzModelSnippetViewer
  configuration={{
    schema_version: '1.1',
    type_definitions: [
      {
        type: 'document',
        relations: {
          viewer: {
            // a user is related to the object as a viewer if:
            union: {
              // they are in any of
              child: [
                {
                  this: {}, // the userset of all users related to the object as "viewer"; indicating that a user can be assigned a direct `viewer` relation, i.e., not implied through another relation
                },
                {
                  computedUserset: {
                    relation: 'editor', // the userset of all users related to the object as "editor"; indicating that a user who is an editor is also implicitly a viewer
                  },
                },
              ],
            },
          },
        },
        metadata: {
          relations: {
            viewer: { directly_related_user_types: [{ type: 'user' }] },
          },
        },
      },
    ],
  }} skipVersion={true}
/>

In the <ProductConcept section="what-is-a-type-definition" linkName="type definition" /> snippet above, `user:anne` is a `viewer` of `document:new-roadmap` if any of the following conditions are satisfied:

- there exists a <ProductConcept section="what-are-direct-and-implied-relationships" linkName="direct relationship" /> with _anne_ as _editor_ of _document:new-roadmap_
  <RelationshipTuplesViewer
    relationshipTuples={[
      {
        user: 'user:anne',
        relation: 'editor',
        object: 'document:new-roadmap',
      },
    ]}
  />
- _anne_ is a _viewer_ of _document:new-roadmap_
  <RelationshipTuplesViewer
    relationshipTuples={[
      {
        user: 'user:anne',
        relation: 'viewer',
        object: 'document:new-roadmap',
      },
    ]}
  />

:::info

The above <ProductConcept section="what-is-an-authorization-model" linkName="authorization model" /> indicates that a user is related as a viewer if they are in any of the following:

- the userset of all users related to the object as "viewer", indicating that a user can be assigned a direct `viewer` relation
- the userset of all users related to the object as "editor", indicating that a user who is an editor is also implicitly a viewer

If `anne` is in at least one of those usersets, meaning `anne` is either an `editor` or a `viewer`, the <ProductConcept section="what-is-a-check-request" linkName="check" /> on `{"user": "user:anne", "relation": "viewer", "object": "document:new-roadmap"}` returns `{"allowed": true}`.

:::

For more examples, see [Modeling Building Blocks: Concentric Relationships](./modeling/building-blocks/concentric-relationships.mdx), [Modeling Roles and Permissions](./modeling/roles-and-permissions.mdx) and [Advanced Modeling: Modeling for IoT](./modeling/advanced/iot.mdx#03-updating-our-authorization-model-to-facilitate-future-changes).

### The Intersection Operator

The **intersection operator** (`and` in the DSL, `intersection` in the JSON syntax) indicates that a <ProductConcept section="what-is-a-relationship" linkName="relationship" /> exists if the <ProductConcept section="what-is-a-user" linkName="user" /> is in all the sets of users.

<AuthzModelSnippetViewer
  configuration={{
    schema_version: '1.1',
    type_definitions: [
      {
        type: 'document',
        relations: {
          viewer: {
            // a user is related to the object as a viewer if
            intersection: {
              // they are in all of
              child: [
                {
                  computedUserset: {
                    // the userset of all users related to the object as "authorized_user"
                    relation: 'authorized_user',
                  },
                },
                {
                  computedUserset: {
                    // the userset of all users related to the object as "editor"
                    relation: 'editor',
                  },
                },
              ],
            },
          },
        },
        metadata: {
          relations: {
            viewer: { directly_related_user_types: [{ type: 'user' }] },
          },
        },
      },
    ],
  }} skipVersion={true}
/>

In the <ProductConcept section="what-is-a-type-definition" linkName="type definition" /> snippet above, `user:anne` is a `viewer` of `document:new-roadmap` if all of the following conditions are satisfied:

- _anne_ is an _editor_ of _document:new-roadmap_
  <RelationshipTuplesViewer
    relationshipTuples={[
      {
        user: 'user:anne',
        relation: 'editor',
        object: 'document:new-roadmap',
      },
    ]}
  />
  AND
- _anne_ is an _authorized_user_ of _document:new-roadmap_:
  <RelationshipTuplesViewer
    relationshipTuples={[
      {
        user: 'user:anne',
        relation: 'authorized_user',
        object: 'document:new-roadmap',
      },
    ]}
  />

:::info

The above <ProductConcept section="what-is-an-authorization-model" linkName="authorization model" /> indicates that a user is related as a viewer if they are in all of the following:

- the userset of all users related to the object as `authorized_user`
- the userset of all users related to the object as `editor`

`anne` must be in the intersection of the usersets (meaning both an `editor` AND an `authorized_user`) for the <ProductConcept section="what-is-a-check-request" linkName="check" /> on `{"user": "user:anne", "relation": "viewer", "object": "document:new-roadmap"}` to return `{"allowed": true}`.

`anne` is not a `viewer` for `document:new-roadmap` if either of the following is true:

- `anne` is not an `editor` to `document:new-roadmap`: no relationship tuple of `{"user": "user:anne", "relation": "editor", "object": "document:new-roadmap"}`
- `anne` is not an `authorized_user` on the `document:new-roadmap`: no relationship tuple of `{"user": "user:anne", "relation": "authorized_user", "object": "document:new-roadmap"}`

:::

For more examples, see [Modeling with Multiple Restrictions](./modeling/multiple-restrictions.mdx).

### The Exclusion Operator

The **exclusion operator** (`but not` in the DSL, `difference` in the JSON syntax) indicates that a <ProductConcept section="what-is-a-relationship" linkName="relationship" /> exists if the <ProductConcept section="what-is-a-user" linkName="user" /> is in the base userset, but not in the excluded userset. It's helpful when modeling exclusion or block lists.

<AuthzModelSnippetViewer
  configuration={{
    schema_version: '1.1',
    type_definitions: [
      {
        type: 'document',
        relations: {
          viewer: {
            // a user is related to the object as a viewer if they are in
            difference: {
              base: {
                this: {}, // the userset of all users related to the object as "viewer"
              },
              subtract: {
                computedUserset: {
                  relation: 'blocked', // but not in the userset of all users related to the object as "blocked"
                },
              },
            },
          },
        },
        metadata: {
          relations: {
            viewer: { directly_related_user_types: [{ type: 'user' }] },
          },
        },
      },
    ],
  }} skipVersion={true}
/>

In the type definition snippet above, `user:anne` is a `viewer` of `document:new-roadmap` if:

- `anne` has a direct relationship as `viewer` to `document:new-roadmap`

  <RelationshipTuplesViewer
    relationshipTuples={[
      {
        user: 'user:anne',
        relation: 'viewer',
        object: 'document:new-roadmap',
      },
    ]}
  />
  AND

- `anne` is not blocked from document:new-roadmap; the following relation tuple **does not exist**:
  <RelationshipTuplesViewer
    relationshipTuples={[
      {
        user: 'user:anne',
        relation: 'blocked',
        object: 'document:new-roadmap',
      },
    ]}
  />

For more information, see [Modeling: Blocklists](./modeling/blocklists.mdx).

:::info

The <ProductConcept section="what-is-an-authorization-model" linkName="authorization model" /> above indicates that a user is related as a viewer if they are in:

- the userset of all users related to the object as `viewer`

but not in:

- the userset of all users related to the object as `blocked`

`anne` must be both a `viewer` and not `blocked` for the <ProductConcept section="what-is-a-check-request" linkName="check" /> on `{"user": "user:anne", "relation": "viewer", "object": "document:new-roadmap"}` to return `{"allowed": true}`.

`anne` is not a viewer for document:new-roadmap if either of the following is true:

- `anne` is **not** assigned direct relationship as viewer to document:new-roadmap: **no relationship tuple of** `{"user": "user:anne", "relation": "viewer", "object": "document:new-roadmap"}`
- `anne` is blocked on the document:new-roadmap `{"user": "user:anne", "relation": "blocked", "object": "document:new-roadmap"}`

:::

## Equivalent Zanzibar Concepts

The JSON syntax accepted by the <ProductName format={ProductNameFormat.ShortForm}/> API closely mirrors the syntax represented in the Zanzibar paper. The major modifications are a slight flattening and conversion of keys from `snake_case` to `camelCase`.

| Zanzibar           | <ProductName format={ProductNameFormat.ShortForm}/> JSON | <ProductName format={ProductNameFormat.ShortForm}/> DSL |
| :----------------- | :------------------------------------------------------- | :------------------------------------------------------ |
| `this`             | `this`                                                   | [`[<type1>,<type2>]`](#the-direct-relationship-type-restrictions)                                                  |
| `union`            | `union`                                                  | `or`                                                    |
| `intersection`     | `intersection`                                           | `and`                                                   |
| `exclusion`        | `difference`                                             | `but not`                                               |
| `tuple_to_userset` | `tupleToUserset`                                         | `x from y`                                              |

The [Zanzibar paper](https://research.google/pubs/pub48190/) presents this example:

```
name: "doc"

relation { name: "owner" }

relation {
  name: "editor"
  userset_rewrite {
    union {
      child { _this {} }
      child { computed_userset { relation: "owner" } }
}}}

relation {
 name: "viewer"
 userset_rewrite {
  union {
    child { _this {} }
    child { computed_userset { relation: "editor" } }
    child { tuple_to_userset {
      tupleset { relation: "parent" }
      computed_userset {
        object: $TUPLE_USERSET_OBJECT  # parent folder
        relation: "viewer" }}}
}}}
```

In the <ProductName format={ProductNameFormat.ShortForm}/> DSL, it becomes:

<AuthzModelSnippetViewer
  onlyShow={SyntaxFormat.Friendly2}
  configuration={{
    schema_version: '1.1',
    type_definitions: [
      {
        type: 'doc',
        relations: {
          owner: {
            this: {},
          },
          editor: {
            union: {
              child: [
                {
                  this: {},
                },
                {
                  computedUserset: {
                    relation: 'owner',
                  },
                },
              ],
            },
          },
          viewer: {
            union: {
              child: [
                {
                  this: {},
                },
                {
                  computedUserset: {
                    relation: 'editor',
                  },
                },
                {
                  tupleToUserset: {
                    tupleset: {
                      relation: 'parent',
                    },
                    computedUserset: {
                      relation: 'viewer',
                    },
                  },
                },
              ],
            },
          },
        },
        metadata: {
          relations: {
            owner: { directly_related_user_types: [{ type: 'user' }] },
            editor: { directly_related_user_types: [{ type: 'user' }] },
            viewer: { directly_related_user_types: [{ type: 'user' }] },
          },
        },
      },
    ],
  }}
/>

In the <ProductName format={ProductNameFormat.ShortForm}/> JSON, it becomes:

<AuthzModelSnippetViewer
  onlyShow={SyntaxFormat.Api}
  configuration={{
    schema_version: '1.1',
    type_definitions: [
      {
        type: 'doc',
        relations: {
          owner: {
            this: {},
          },
          editor: {
            union: {
              child: [
                {
                  this: {},
                },
                {
                  computedUserset: {
                    relation: 'owner',
                  },
                },
              ],
            },
          },
          viewer: {
            union: {
              child: [
                {
                  this: {},
                },
                {
                  computedUserset: {
                    relation: 'editor',
                  },
                },
                {
                  tupleToUserset: {
                    tupleset: {
                      relation: 'parent',
                    },
                    computedUserset: {
                      relation: 'viewer',
                    },
                  },
                },
              ],
            },
          },
        },
        metadata: {
          relations: {
            owner: { directly_related_user_types: [{ type: 'user' }] },
            editor: { directly_related_user_types: [{ type: 'user' }] },
            viewer: { directly_related_user_types: [{ type: 'user' }] },
          },
        },
      },
    ],
  }}
/>

The following snippet:

<AuthzModelSnippetViewer
  configuration={{
    schema_version: '1.1',
    type_definitions: [
      {
        type: 'doc',
        relations: {
          viewer: {
            union: {
              child: [
                {
                  // a user can be assigned a direct `viewer` relation, i.e., not implied through another relation
                  this: {},
                },
                {
                  // a user that is an editor is also implicitly a viewer
                  computedUserset: {
                    relation: 'editor',
                  },
                },
                {
                  // a user that is an viewer on any of the object's parents is also implicitly a viewer on the object
                  tupleToUserset: {
                    tupleset: {
                      relation: 'parent',
                    },
                    computedUserset: {
                      relation: 'viewer',
                    },
                  },
                },
              ],
            },
          },
        },
        metadata: {
          relations: {
            viewer: { directly_related_user_types: [{ type: 'user' }] },
          },
        },
      },
    ],
  }}
/>

Results in the following outcome:

- The users with a viewer relationship to a certain doc are any of:
  - the set of users who are <ProductConcept section="what-are-direct-and-implied-relationships" linkName="directly related" /> with this doc as `viewer`
  - the set of users who are related to this doc as `editor`
  - the set of users who are related to any object OBJ_1 as `viewer`, where object OBJ_1 is any object related to this doc as `parent` (e.g. viewers of this doc's parent folder, where the parent folder is OBJ_1)

Learn more about Zanzibar at the [Zanzibar Academy](https://zanzibar.academy).

## Related Sections

<RelatedSection
  description="Check the following sections for more on how to use the configuration language in modeling authorization."
  relatedLinks={[
    {
      title: '{ProductName} Concepts',
      description: 'Learn about the {ProductName} Concepts.',
      link: './concepts',
      id: './concepts',
    },
    {
      title: 'Modeling: Getting Started',
      description: 'Learn about how to get started with modeling your permission system in {ProductName}.',
      link: './modeling/getting-started',
      id: './modeling/getting-started',
    },
    {
      title: 'Direct Access',
      description: 'Learn about modeling user access to an object.',
      link: './modeling/direct-access',
      id: './modeling/direct-access',
    },
  ]}
/>
