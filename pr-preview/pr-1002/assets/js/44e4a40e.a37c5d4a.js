"use strict";(self.webpackChunkopenfga_dev=self.webpackChunkopenfga_dev||[]).push([[6014],{8317:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>h,contentTitle:()=>c,default:()=>l,frontMatter:()=>a,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"content/best-practices/source-of-truth","title":"Source of Truth","description":"Deciding where to store the \\"source of truth\\" for authorization data","source":"@site/docs/content/best-practices/source-of-truth.mdx","sourceDirName":"content/best-practices","slug":"/best-practices/source-of-truth","permalink":"/pr-preview/pr-1002/docs/best-practices/source-of-truth","draft":false,"unlisted":false,"editUrl":"https://github.com/openfga/openfga.dev/edit/main/docs/content/best-practices/source-of-truth.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Source of Truth","sidebar_position":3,"slug":"/best-practices/source-of-truth","description":"Deciding where to store the \\"source of truth\\" for authorization data"},"sidebar":"docs","previous":{"title":"Adoption Patterns","permalink":"/pr-preview/pr-1002/docs/best-practices/adoption-patterns"}}');var s=r(74848),i=r(28453),n=r(89987);const a={title:"Source of Truth",sidebar_position:3,slug:"/best-practices/source-of-truth",description:'Deciding where to store the "source of truth" for authorization data'},c='Storing the "source of truth" for authorization data',h={},d=[];function u(e){const t={a:"a",h1:"h1",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"storing-the-source-of-truth-for-authorization-data",children:'Storing the "source of truth" for authorization data'})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(n.bU,{format:n.Ed.ShortForm})," is inspired by ",(0,s.jsx)(t.a,{href:"https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/",children:"Google\u2019s Zanzibar"}),". In Google\u2019s architecture, Zanzibar is an extremely efficient system for authorization checks\u2014but it's never the source of truth for application data. The ",(0,s.jsx)(t.a,{href:"https://openfga.dev/docs/interacting/relationship-queries#read",children:"Read endpoint"})," is mostly used when you need to inspect the stored data, like troubleshooting consistency issues."]}),"\n",(0,s.jsxs)(t.p,{children:["For developers building with ",(0,s.jsx)(n.bU,{format:n.Ed.ShortForm})," , following Google's approach isn't always practical. In most cases, applications will use ",(0,s.jsx)(n.bU,{format:n.Ed.ShortForm})," as the source of truth for some data, but not for everything."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsxs)(t.strong,{children:["When ",(0,s.jsx)(n.bU,{format:n.Ed.ShortForm}),"  is not the right source of truth:"]})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"User data: Your user directory (profiles, groups, attributes like manager or department) typically lives in your identity provider. In SaaS apps, this is often your customer's IdP."}),"\n",(0,s.jsx)(t.li,{children:"Entity hierarchies: Structures like project/tickets or folder/documents already live in your app's database. Repeatedly querying OpenFGA just to navigate that hierarchy would be inefficient."}),"\n",(0,s.jsx)(t.li,{children:"Search and filtering: When performing searches, you need to combine data that's on your database and data that's in OpenFGA. Your application's database is the right place to do filtering/sorting/joins. That data should be present on your database."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"When OpenFGA is a good source of truth:"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Fine-grained permissions: If your app allows users to assign permissions directly to resources (e.g., sharing a document), and you don't already store that data, OpenFGA works well as the source of truth."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Role membership: If you are not using another system to manage roles, storing role membership in OpenFGA is reasonable. Just remember that OpenFGA does not store role metadata (like names or descriptions), so you'll still need a 'Roles' table in your app."}),"\n"]}),"\n"]})]})}function l(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}}}]);