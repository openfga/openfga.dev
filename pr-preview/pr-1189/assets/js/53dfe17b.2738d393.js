"use strict";(globalThis.webpackChunkopenfga_dev=globalThis.webpackChunkopenfga_dev||[]).push([[2728],{10287(e,n,i){i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"content/best-practices/modeling-design-principles","title":"Authorization Model Design Principles","description":"Best practices for creating clear, performant, and maintainable authorization models.","source":"@site/docs/content/best-practices/modeling-design-principles.mdx","sourceDirName":"content/best-practices","slug":"/best-practices/modeling-design-principles","permalink":"/pr-preview/pr-1189/docs/best-practices/modeling-design-principles","draft":false,"unlisted":false,"editUrl":"https://github.com/openfga/openfga.dev/edit/main/docs/content/best-practices/modeling-design-principles.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Authorization Model Design Principles","slug":"/best-practices/modeling-design-principles","description":"Best practices for creating clear, performant, and maintainable authorization models.","sidebar_position":1},"sidebar":"docs","previous":{"title":"Adoption Patterns","permalink":"/pr-preview/pr-1189/docs/best-practices/adoption-patterns"},"next":{"title":"Modeling ABAC","permalink":"/pr-preview/pr-1189/docs/best-practices/modeling-abac"}}');var s=i(74848),o=i(28453),t=i(8746);const a={title:"Authorization Model Design Principles",slug:"/best-practices/modeling-design-principles",description:"Best practices for creating clear, performant, and maintainable authorization models.",sidebar_position:1},d="Authorization Model Design Principles",l={},c=[{value:"Core Principle: Model Your Domain, Not a Meta-Model",id:"core-principle-model-your-domain-not-a-meta-model",level:2},{value:"The Recommended Approach",id:"the-recommended-approach",level:3},{value:"Modeling Roles",id:"modeling-roles",level:2},{value:"Built-in Roles",id:"built-in-roles",level:3},{value:"Custom Roles (User-Defined)",id:"custom-roles-user-defined",level:3},{value:"Modeling Organizational Structures",id:"modeling-organizational-structures",level:2},{value:"Super-Admin Access",id:"super-admin-access",level:3},{value:"Customer Organization Hierarchies",id:"customer-organization-hierarchies",level:3},{value:"Modeling Resource Types",id:"modeling-resource-types",level:2},{value:"Use Specific Types, Not a Generic &quot;Resource&quot;",id:"use-specific-types-not-a-generic-resource",level:3},{value:"Quick Reference",id:"quick-reference",level:2},{value:"Related Sections",id:"related-sections",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components},{Details:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"authorization-model-design-principles",children:"Authorization Model Design Principles"})}),"\n",(0,s.jsxs)(n.p,{children:["A well-designed authorization model is easier to understand, debug, and maintain. It also performs better and scales more gracefully as your application grows. This guide covers key principles for modeling authorization in ",(0,s.jsx)(t.bU,{format:t.Ed.ShortForm}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"core-principle-model-your-domain-not-a-meta-model",children:"Core Principle: Model Your Domain, Not a Meta-Model"}),"\n",(0,s.jsxs)(n.p,{children:["The most common mistake when starting with ",(0,s.jsx)(t.bU,{format:t.Ed.ShortForm}),' is creating an overly generic model that can represent "anything." While this seems flexible, it trades clarity for abstraction and often hurts performance.']}),"\n",(0,s.jsxs)(n.admonition,{title:"Rule of Thumb",type:"tip",children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"If end-users can define it, store it in tuples. If it's built into your application, define it in the model."})}),(0,s.jsxs)(n.p,{children:['For example: built-in roles like "admin" or "billing_manager" should be relations in your model. User-defined custom roles should be stored as tuples with a ',(0,s.jsx)(n.code,{children:"role"})," type."]})]}),"\n",(0,s.jsx)(n.h3,{id:"the-recommended-approach",children:"The Recommended Approach"}),"\n",(0,s.jsx)(n.p,{children:"Define types and relations that mirror your application's domain. If your app has organizations, projects, and documents, model exactly that with explicit relationships:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dsl.openfga",children:"model\n  schema 1.1\n\ntype user\n\ntype organization\n  relations\n    define admin: [user]\n    define member: [user]\n\ntype project\n  relations\n    define org: [organization]\n    define lead: [user]\n    define member: [user] or member from org\n\ntype document\n  relations\n    define project: [project]\n    define owner: [user]\n    define editor: [user] or owner or lead from project\n    define viewer: [user] or editor or member from project\n"})}),"\n",(0,s.jsx)(n.p,{children:"Notice how this model has a clear hierarchy (organization \u2192 project \u2192 document) where each type and relationship directly reflects the application's domain. Permission inheritance follows a well-defined path that's easy to understand and audit."}),"\n",(0,s.jsx)(n.p,{children:"This approach has several advantages:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Enhanced clarity and maintainability"}),": Authorization logic is easier to understand, debug, and maintain. Developers and security auditors can readily grasp the meaning of each type and relationship just by reading the model."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Better performance"}),": Models with specific types and flatter hierarchies perform better. ",(0,s.jsx)(t.bU,{format:t.Ed.ShortForm})," processes queries more efficiently with well-defined types compared to navigating complex recursive relationships within generic types."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Easier evolution"}),": ",(0,s.jsx)(t.bU,{format:t.Ed.ShortForm}),"'s modeling language is designed to be adaptable. You can define numerous distinct types and relationships without significant overhead. Model changes rarely require data migrations, allowing you to evolve your model as your application grows."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Team autonomy with modules"}),": Resource types owned by each application team can be maintained in independent ",(0,s.jsx)(n.a,{href:"/pr-preview/pr-1189/docs/modeling/modular-models",children:"modules"}),". You can control which application can write to specific resource types through API credentials, providing better security boundaries."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"What to avoid: The overly generic model"}),(0,s.jsx)(n.p,{children:"The model below can technically represent any organization hierarchy, any resource hierarchy, and any role hierarchy:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dsl.openfga",children:"model\n  schema 1.1\n\ntype user\n\ntype role\n  relations\n    define assignee: [user, role#assignee]\n\ntype entity\n  relations\n    define parent: [entity]\n    define editor: [role#assignee] or editor from parent\n    define viewer: [role#assignee] or editor or viewer from parent\n\ntype resource\n  relations\n    define entity: [entity]\n    define parent: [resource]\n    define editor: [role#assignee] or editor from entity or editor from parent\n    define viewer: [role#assignee] or editor or viewer from parent\n"})}),(0,s.jsx)(n.p,{children:"While flexible, this approach creates problems:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The model doesn't communicate what your application actually does"}),"\n",(0,s.jsx)(n.li,{children:"To understand the actual relationships you need to rely on tuples, e.g., the fact that a project can have documents."}),"\n",(0,s.jsx)(n.li,{children:"Generic recursive relations are slower to evaluate"}),"\n",(0,s.jsx)(n.li,{children:"You can't use modules to isolate different resource types"}),"\n",(0,s.jsx)(n.li,{children:'ListObjects returns mixed results (all "resources" instead of just "documents")'}),"\n"]})]}),"\n",(0,s.jsx)(n.h2,{id:"modeling-roles",children:"Modeling Roles"}),"\n",(0,s.jsx)(n.p,{children:"Most applications have roles. The key question is: are they built-in or user-defined?"}),"\n",(0,s.jsx)(n.h3,{id:"built-in-roles",children:"Built-in Roles"}),"\n",(0,s.jsx)(n.p,{children:"For roles that come with your application (admin, member, viewer, etc.), define them directly as relations:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dsl.openfga",children:"model\n  schema 1.1\n\ntype user\n\ntype organization\n  relations\n    define admin: [user]\n    define member: [user]\n    define billing_manager: [user]\n\n    define can_manage_billing: admin or billing_manager\n    define can_manage_users: admin\n    define can_view_dashboard: admin or member\n"})}),"\n",(0,s.jsx)(n.p,{children:"Adding new built-in roles is straightforward: add a relation to the model. This happens infrequently and doesn't require data migration."}),"\n",(0,s.jsx)(n.h3,{id:"custom-roles-user-defined",children:"Custom Roles (User-Defined)"}),"\n",(0,s.jsxs)(n.p,{children:["Some applications let end-users create their own roles. In this case, combine static roles with a dynamic ",(0,s.jsx)(n.code,{children:"role"})," type:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dsl.openfga",children:"model\n  schema 1.1\n\ntype user\n\ntype role\n  relations\n    define assignee: [user]\n\ntype organization\n  relations\n    # Built-in roles\n    define admin: [user]\n    define billing_manager: [user]\n\n    # Permissions combine built-in and custom roles\n    define can_manage_billing: [role#assignee] or admin or billing_manager\n    define can_manage_users: [role#assignee] or admin\n"})}),"\n",(0,s.jsx)(n.p,{children:"This hybrid approach gives you the clarity of static roles for common cases while supporting custom roles when needed."}),"\n",(0,s.jsxs)(n.p,{children:["For more details, see ",(0,s.jsx)(n.a,{href:"./modeling-roles",children:"Modeling Roles"})," and ",(0,s.jsx)(n.a,{href:"./../modeling/custom-roles",children:"Custom Roles"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"modeling-organizational-structures",children:"Modeling Organizational Structures"}),"\n",(0,s.jsx)(n.p,{children:"B2B SaaS applications often have two distinct organizational requirements:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Super-admin access"}),": Your company's employees need to access customer data for support or disaster recovery"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Customer hierarchies"}),": Your customers have their own organizational structures"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"super-admin-access",children:"Super-Admin Access"}),"\n",(0,s.jsxs)(n.p,{children:["For internal support and admin access, use a dedicated ",(0,s.jsx)(n.code,{children:"system"})," type rather than making organizations recursive:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dsl.openfga",children:"model\n  schema 1.1\n\ntype user\n\ntype system\n  relations\n    define admin: [user]\n\ntype organization\n  relations\n    define system: [system]\n    define admin: [user] or admin from system\n    define member: [user]\n"})}),"\n",(0,s.jsx)(n.p,{children:"This approach:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Clearly separates your internal access from customer access"}),"\n",(0,s.jsx)(n.li,{children:"Avoids recursive relations (faster to evaluate)"}),"\n",(0,s.jsx)(n.li,{children:"Makes audit and compliance reviews easier"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["See a complete ",(0,s.jsx)(n.a,{href:"https://github.com/openfga/sample-stores/blob/main/stores/superadmin",children:"super-admin example"})," for more details."]}),"\n",(0,s.jsx)(n.h3,{id:"customer-organization-hierarchies",children:"Customer Organization Hierarchies"}),"\n",(0,s.jsx)(n.p,{children:"If customers need hierarchical organizations, prefer explicit types for each level when the structure is well-defined:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dsl.openfga",children:"model\n  schema 1.1\n\ntype user\n\ntype system\n  relations\n    define admin: [user]\n\ntype organization\n  relations\n    define system: [system]\n    define admin: [user] or admin from system\n    define member: [user]\n\ntype department\n  relations\n    define org: [organization]\n    define manager: [user]\n    define member: [user] or member from org\n"})}),"\n",(0,s.jsx)(n.p,{children:"This makes the hierarchy explicit: organizations contain departments, and department members inherit from the organization."}),"\n",(0,s.jsx)(n.p,{children:"If the hierarchy depth is truly dynamic (customers can nest arbitrarily), then add recursion only where needed:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dsl.openfga",children:"model\n  schema 1.1\n\ntype user\n\ntype system\n  relations\n    define admin: [user]\n\ntype organization\n  relations\n    define system: [system]\n    define parent: [organization]\n    define admin: [user] or admin from system or admin from parent\n    define member: [user] or member from parent\n"})}),"\n",(0,s.jsx)(n.p,{children:"Now you have two distinct hierarchies:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"System hierarchy"}),": Non-recursive, for your internal super-admin access"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Organization hierarchy"}),": Recursive only if customers truly need arbitrary nesting"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Prefer explicit types when possible; use recursion only when the depth is genuinely unbounded."}),"\n",(0,s.jsx)(n.h2,{id:"modeling-resource-types",children:"Modeling Resource Types"}),"\n",(0,s.jsx)(n.p,{children:"Applications have different kinds of resources: documents, folders, projects, tickets, accounts, etc. Some have parent-child relationships (folders contain documents, projects contain tickets)."}),"\n",(0,s.jsx)(n.h3,{id:"use-specific-types-not-a-generic-resource",children:'Use Specific Types, Not a Generic "Resource"'}),"\n",(0,s.jsx)(n.p,{children:"Define a type for each kind of resource in your application:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dsl.openfga",children:"model\n  schema 1.1\n\ntype user\n\ntype folder\n  relations\n    define parent: [folder]\n    define owner: [user]\n    define editor: [user] or owner or editor from parent\n    define viewer: [user] or editor or viewer from parent\n\ntype document\n  relations\n    define parent: [folder]\n    define owner: [user]\n    define editor: [user] or owner or editor from parent\n    define viewer: [user] or editor or viewer from parent\n    define can_print: [user] or owner\n    define can_share: owner\n"})}),"\n",(0,s.jsx)(n.p,{children:"Benefits of specific types:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Accurate ListObjects results"}),": Querying for documents returns only documents, not all resources"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type-specific permissions"}),": ",(0,s.jsx)(n.code,{children:"can_print"})," makes sense for documents but not folders"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Clearer model"}),": Each type shows exactly what permissions apply to it"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Module support"}),": Different teams can own different resource types"]}),"\n"]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"What to avoid: The generic resource type"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dsl.openfga",children:"type resource\n  relations\n    define entity: [entity]\n    define parent: [resource]\n    define editor: [role#assignee] or editor from entity or editor from parent\n    define viewer: [role#assignee] or editor or viewer from parent\n"})}),(0,s.jsx)(n.p,{children:"Problems with this approach:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"ListObjects returns mixed results (folders, documents, and everything else)"}),"\n",(0,s.jsx)(n.li,{children:"You end up with a superset of all permissions, making it unclear which apply to what"}),"\n",(0,s.jsx)(n.li,{children:"No way to use modules for team ownership"}),"\n",(0,s.jsx)(n.li,{children:"Harder to understand and audit"}),"\n"]})]}),"\n",(0,s.jsx)(n.h2,{id:"quick-reference",children:"Quick Reference"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Scenario"}),(0,s.jsx)(n.th,{children:"Recommendation"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Built-in roles (admin, member)"}),(0,s.jsx)(n.td,{children:"Define as relations directly in the model"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"User-defined custom roles"}),(0,s.jsxs)(n.td,{children:["Create a ",(0,s.jsx)(n.code,{children:"role"})," type, store assignments as tuples"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Internal super-admin access"}),(0,s.jsxs)(n.td,{children:["Use a non-recursive ",(0,s.jsx)(n.code,{children:"system"})," type"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Customer org hierarchies"}),(0,s.jsxs)(n.td,{children:["Add recursive ",(0,s.jsx)(n.code,{children:"parent"})," relation only if needed"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Different resource types"}),(0,s.jsxs)(n.td,{children:["Create specific types (",(0,s.jsx)(n.code,{children:"document"}),", ",(0,s.jsx)(n.code,{children:"folder"}),"), not generic ",(0,s.jsx)(n.code,{children:"resource"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Type-specific permissions"}),(0,s.jsx)(n.td,{children:"Define permissions on the relevant type only"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Team ownership of resource types"}),(0,s.jsx)(n.td,{children:"Use modules to separate concerns"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"related-sections",children:"Related Sections"}),"\n",(0,s.jsx)(t.XQ,{description:"Check out these related resources for more information about modeling in OpenFGA",relatedLinks:[{title:"Custom Roles",description:"Learn how to implement user-defined custom roles.",link:"./../modeling/custom-roles"},{title:"Modular Authorization Models",description:"Learn how to break down your authorization model into modules.",link:"./../modeling/modular-models"},{title:"Modeling Roles",description:"Detailed guidance on role-based access control patterns.",link:"./modeling-roles"},{title:"Building Blocks",description:"Understand the fundamental concepts for building authorization models.",link:"./../modeling/building-blocks"}]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}}}]);