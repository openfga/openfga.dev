"use strict";(self.webpackChunkopenfga_dev=self.webpackChunkopenfga_dev||[]).push([[6588],{47439:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"content/best-practices/abac-considerations","title":"ABAC Considerations with OpenFGA","description":"Guidelines for implementing Attribute-Based Access Control with OpenFGA","source":"@site/docs/content/best-practices/abac-considerations.md","sourceDirName":"content/best-practices","slug":"/best-practices/abac-considerations","permalink":"/pr-preview/pr-1126/docs/best-practices/abac-considerations","draft":false,"unlisted":false,"editUrl":"https://github.com/openfga/openfga.dev/edit/main/docs/content/best-practices/abac-considerations.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"ABAC Considerations with OpenFGA","slug":"/best-practices/abac-considerations","description":"Guidelines for implementing Attribute-Based Access Control with OpenFGA","sidebar_position":4}}');var t=i(74848),r=i(28453),a=i(25558);const l={title:"ABAC Considerations with OpenFGA",slug:"/best-practices/abac-considerations",description:"Guidelines for implementing Attribute-Based Access Control with OpenFGA",sidebar_position:4},o="Implementing ABAC with ",c={},d=[{value:"Quick Decision Guide",id:"quick-decision-guide",level:2},{value:"Implementation Approaches",id:"implementation-approaches",level:2},{value:"Approach 1: Categorical Relationships",id:"approach-1-categorical-relationships",level:3},{value:"Approach 2: Boolean Attributes",id:"approach-2-boolean-attributes",level:3},{value:"Approach 3: Conditions with Runtime Comparisons",id:"approach-3-conditions-with-runtime-comparisons",level:3},{value:"Approach 4: Resource Tagging",id:"approach-4-resource-tagging",level:3},{value:"Approach 5: Contextual Tuples",id:"approach-5-contextual-tuples",level:3},{value:"Approach 6: Hybrid",id:"approach-6-hybrid",level:3},{value:"Common ABAC Patterns",id:"common-abac-patterns",level:2},{value:"Decision Framework Details",id:"decision-framework-details",level:2},{value:"1. Request-Specific Attributes and Runtime Comparisons",id:"1-request-specific-attributes-and-runtime-comparisons",level:3},{value:"2. Boolean Flags",id:"2-boolean-flags",level:3},{value:"3. Multiple Resource Attributes",id:"3-multiple-resource-attributes",level:3},{value:"4. Readily Available Attributes",id:"4-readily-available-attributes",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Decision Tree",id:"decision-tree",level:2},{value:"Related Sections",id:"related-sections",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsxs)(n.h1,{id:"implementing-abac-with-",children:["Implementing ABAC with ",(0,t.jsx)(a.bU,{format:a.Ed.ShortForm})]})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(a.bU,{format:a.Ed.ShortForm})," is primarily a Relationship-Based Access Control (ReBAC) system, but it can effectively handle many Attribute-Based Access Control (ABAC) scenarios through ",(0,t.jsx)(n.a,{href:"/pr-preview/pr-1126/docs/modeling/conditions",children:"Conditions"}),", ",(0,t.jsx)(n.a,{href:"/pr-preview/pr-1126/docs/modeling/token-claims-contextual-tuples",children:"Contextual Tuples"}),", and modeling attributes as relationships. This guide helps you choose the best approach for your ABAC use cases."]}),"\n",(0,t.jsx)(n.h2,{id:"quick-decision-guide",children:"Quick Decision Guide"}),"\n",(0,t.jsx)(n.p,{children:"Ask these four questions about each attribute to determine the best implementation approach:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Question"}),(0,t.jsx)(n.th,{children:"If YES \u2192"}),(0,t.jsx)(n.th,{children:"If NO \u2192"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.strong,{children:"1. Request-specific or needs comparison?"})," (time, IP, usage vs limit)"]}),(0,t.jsxs)(n.td,{children:["Use ",(0,t.jsx)(n.strong,{children:"Conditions"})]}),(0,t.jsx)(n.td,{children:"Continue to #2"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.strong,{children:"2. Is it a boolean flag?"})," (email_verified, active)"]}),(0,t.jsxs)(n.td,{children:["Use ",(0,t.jsx)(n.strong,{children:"Boolean Relationships"})]}),(0,t.jsx)(n.td,{children:"Continue to #3"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.strong,{children:"3. Does the resource have multiple tags?"})," (status + sensitivity)"]}),(0,t.jsxs)(n.td,{children:["Use ",(0,t.jsx)(n.strong,{children:"Resource Tagging"})]}),(0,t.jsx)(n.td,{children:"Continue to #4"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.strong,{children:"4. Is it readily available?"})," (JWT claims)"]}),(0,t.jsxs)(n.td,{children:["Use ",(0,t.jsx)(n.strong,{children:"Contextual Tuples"})]}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Store as tuples"})})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"implementation-approaches",children:"Implementation Approaches"}),"\n",(0,t.jsx)(n.p,{children:"All examples in this section use a consistent document management scenario with users Alice (content team) and Bob (marketing team)."}),"\n",(0,t.jsx)(n.h3,{id:"approach-1-categorical-relationships",children:"Approach 1: Categorical Relationships"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use when:"})," Attributes represent stable categorical relationships (department, role, team membership)"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Example:"})," Department-based document access"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dsl.openfga",children:"model\n  schema 1.1\n\ntype user\n\ntype department\n  relations\n    define member: [user]\n\ntype document\n  relations\n    define viewer: [department#member]\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'// Write relationships\nawait fgaClient.write({\n  writes: [\n    { user: "user:alice", relation: "member", object: "department:content" },\n    { user: "department:content#member", relation: "viewer", object: "document:roadmap" }\n  ]\n});\n\n// Check access\nawait fgaClient.check({\n  user: "user:alice",\n  relation: "viewer",\n  object: "document:roadmap"\n});\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Pros:"})," Native ReBAC, efficient queries, supports ListObjects/ListUsers, good audit trail"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"approach-2-boolean-attributes",children:"Approach 2: Boolean Attributes"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use when:"})," Attributes are true/false flags that change occasionally (email_verified, account_active, terms_accepted)"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Example:"})," Email verification requirement for document access"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dsl.openfga",children:"model\n  schema 1.1\n\ntype user\n  relations\n    define email_verified: [user]\n\ntype document\n  relations\n    define viewer: [user]\n    define can_view: email_verified from viewer\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'// When user verifies email\nawait fgaClient.write({\n  writes: [{\n    user: "user:alice",\n    relation: "email_verified",\n    object: "user:alice"\n  }]\n});\n\n// Grant document access\nawait fgaClient.write({\n  writes: [{\n    user: "user:alice",\n    relation: "viewer",\n    object: "document:roadmap"\n  }]\n});\n\n// Check - returns true only if Alice is viewer AND has email_verified\nawait fgaClient.check({\n  user: "user:alice",\n  relation: "can_view",\n  object: "document:roadmap"\n});\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Alternative syntax:"})," You can use ",(0,t.jsx)(n.code,{children:"[user:*]"})," instead of ",(0,t.jsx)(n.code,{children:"[user]"})," and write ",(0,t.jsx)(n.code,{children:"user:*"})," as the subject. Both work identically."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dsl.openfga",children:"model\n  schema 1.1\n\ntype user\n  relations\n    define email_verified: [user:*]\n\ntype document\n  relations\n    define viewer: [user]\n    define can_view: email_verified from viewer\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'// When user verifies email - note the user:* syntax\nawait fgaClient.write({\n  writes: [{\n    user: "user:*",\n    relation: "email_verified",\n    object: "user:alice"\n  }]\n});\n\n// Grant document access (same as before)\nawait fgaClient.write({\n  writes: [{\n    user: "user:alice",\n    relation: "viewer",\n    object: "document:roadmap"\n  }]\n});\n\n// Check - returns true only if Alice is viewer AND has email_verified\nawait fgaClient.check({\n  user: "user:alice",\n  relation: "can_view",\n  object: "document:roadmap"\n});\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Pros:"})," Pure ReBAC, works with all APIs, no evaluation limits, clear semantics\n",(0,t.jsx)(n.strong,{children:"Cons:"})," Requires sync when flags change, only for binary states"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"approach-3-conditions-with-runtime-comparisons",children:"Approach 3: Conditions with Runtime Comparisons"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Use when:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Attributes vary per request (current time, IP address, transaction amount)"}),"\n",(0,t.jsx)(n.li,{children:"You need to compare stored policy values against runtime state (quota limits vs. current usage)"}),"\n",(0,t.jsx)(n.li,{children:"Attributes cannot be modeled as relationships but need to be evaluated at check time"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Example 1:"})," Time-based document access"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dsl.openfga",children:"model\n  schema 1.1\n\ntype user\n\ntype document\n  relations\n    define viewer: [user with time_restriction]\n\ncondition time_restriction(current_time: timestamp, allowed_start: timestamp, allowed_end: timestamp) {\n  current_time >= allowed_start && current_time <= allowed_end\n}\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'// Grant time-limited access\nawait fgaClient.write({\n  writes: [{\n    user: "user:alice",\n    relation: "viewer",\n    object: "document:roadmap",\n    condition: {\n      name: "time_restriction",\n      context: {\n        allowed_start: "2024-01-01T00:00:00Z",\n        allowed_end: "2024-12-31T23:59:59Z"\n      }\n    }\n  }]\n});\n\n// Check with current time\nawait fgaClient.check({\n  user: "user:alice",\n  relation: "viewer",\n  object: "document:roadmap",\n  context: {\n    current_time: new Date().toISOString()\n  }\n});\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Example 2:"})," Entitlements with stored limits and runtime comparison"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dsl.openfga",children:"model\n  schema 1.1\n\ntype user\n\ntype organization\n  relations\n    define member: [user with quota_limit]\n    define can_invite : member\n\ncondition quota_limit(current_invite_count: int, max_invites: int) {\n  current_invite_count < max_invites\n}\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'// Store the quota limit when granting membership\nawait fgaClient.write({\n  writes: [{\n    user: "user:alice",\n    relation: "member",\n    object: "organization:acme",\n    condition: {\n      name: "quota_limit",\n      context: {\n        max_invites: 5  // Store policy limit: free plan allows 5 invites\n      }\n    }\n  }]\n});\n\n// At check time, fetch current usage and compare\nconst currentInviteCount = await db.getInviteCount("user:alice", "organization:acme");\n\nawait fgaClient.check({\n  user: "user:alice",\n  relation: "can_invite",\n  object: "organization:acme",\n  context: {\n    current_invite_count: currentInviteCount  // Compare against stored limit\n  }\n});\n// Returns true if currentInviteCount < 5, false otherwise\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Key insight:"})," Use Conditions when you need to:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Store policy values"})," (limits, thresholds, allowed ranges) in the tuple context"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Compare them against runtime state"})," (current usage, transaction amount, resource count) provided at check time"]}),"\n",(0,t.jsx)(n.li,{children:"This works even if the runtime value requires a database lookup before the check"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Pros:"})," Handles dynamic attributes, stores policy limits in tuples, flexible CEL expressions, no sync needed for runtime values\n",(0,t.jsx)(n.strong,{children:"Cons:"})," Context size limits (32KB stored, 512KB request), evaluation cost limits, requires fetching runtime state before check"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"approach-4-resource-tagging",children:"Approach 4: Resource Tagging"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use when:"})," Resources have multiple attributes and different groups access different attribute combinations"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Example:"})," Documents with status and sensitivity tags"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dsl.openfga",children:'model\n  schema 1.1\n\ntype user\n\ntype group\n  relations\n    define member: [user]\n    define can_view_docs: [group with doc_policy] from parent_org\n\ntype document\n  relations\n    define parent_org: [organization]\n    define can_view: can_view_docs from parent_org\n\ntype organization\n  relations\n    define member: [user]\n\ncondition doc_policy(doc_attrs: map<string>, allowed_statuses: list<string>, allowed_sensitivities: list<string>) {\n  doc_attrs["status"] in allowed_statuses && doc_attrs["sensitivity"] in allowed_sensitivities\n}\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'// Define group access policies\nawait fgaClient.write({\n  writes: [\n    {\n      // Content team: draft+published, any sensitivity\n      user: "group:content#member",\n      relation: "can_view_docs",\n      object: "organization:acme",\n      condition: {\n        name: "doc_policy",\n        context: {\n          allowed_statuses: ["draft", "published"],\n          allowed_sensitivities: ["public", "internal", "confidential"]\n        }\n      }\n    },\n    {\n      // Marketing team: only published+public\n      user: "group:marketing#member",\n      relation: "can_view_docs",\n      object: "organization:acme",\n      condition: {\n        name: "doc_policy",\n        context: {\n          allowed_statuses: ["published"],\n          allowed_sensitivities: ["public"]\n        }\n      }\n    }\n  ]\n});\n\n// Check access with document attributes\nawait fgaClient.check({\n  user: "user:alice",\n  relation: "can_view",\n  object: "document:roadmap",\n  context: {\n    doc_attrs: {\n      status: "draft",\n      sensitivity: "internal"\n    }\n  }\n});\n// Returns true for Alice (content team), false for Bob (marketing team)\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Pros:"})," Flexible policies, add new tag values without model changes, multiple attributes\n",(0,t.jsx)(n.strong,{children:"Cons:"})," Must provide attributes per check, can't use ListObjects without known attributes"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"approach-5-contextual-tuples",children:"Approach 5: Contextual Tuples"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use when:"})," Attributes are readily available (JWT claims, session data) but shouldn't be stored"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Example:"})," Group membership from access tokens"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dsl.openfga",children:"model\n  schema 1.1\n\ntype user\n\ntype group\n  relations\n    define member: [user]\n\ntype document\n  relations\n    define viewer: [group#member]\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'// Extract groups from JWT: { groups: ["content", "marketing"] }\nawait fgaClient.check({\n  user: "user:alice",\n  relation: "viewer",\n  object: "document:roadmap",\n  contextual_tuples: [\n    { user: "user:alice", relation: "member", object: "group:content" },\n    { user: "user:alice", relation: "member", object: "group:marketing" }\n  ]\n});\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Pros:"})," No sync required, uses existing token infrastructure, good for migrations\n",(0,t.jsx)(n.strong,{children:"Cons:"})," Can't use with ReadChanges/Expand, harder for permission-aware search"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"approach-6-hybrid",children:"Approach 6: Hybrid"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use when:"})," Real-world scenarios with multiple attribute types"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Example:"})," Combine stored relationships, boolean flags, and time restrictions"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dsl.openfga",children:"model\n  schema 1.1\n\ntype user\n  relations\n    define email_verified: [user]\n\ntype department\n  relations\n    define member: [user]\n\ntype document\n  relations\n    define owner: [user]\n    define viewer: [user with time_restriction, department#member]\n    define viewer_email_verified: email_verified from viewer\n\n    define can_view: owner or viewer_email_verified\n\ncondition time_restriction(current_time: timestamp, allowed_start: timestamp, allowed_end: timestamp) {\n  current_time >= allowed_start && current_time <= allowed_end\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"This combines:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Stored tuples:"})," Department membership (slow-changing)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Boolean relationships:"})," Email verification"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Conditions:"})," Time-based access"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Contextual tuples:"})," Can be added for JWT claims"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"common-abac-patterns",children:"Common ABAC Patterns"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Pattern"}),(0,t.jsx)(n.th,{children:"Characteristics"}),(0,t.jsx)(n.th,{children:"Approach"}),(0,t.jsx)(n.th,{children:"Sample"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Time-based access"})}),(0,t.jsx)(n.td,{children:"Request-specific, per-request"}),(0,t.jsx)(n.td,{children:"Conditions"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"https://github.com/openfga/sample-stores/tree/main/stores/temporal-access",children:"Temporal Access"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"IP allowlists"})}),(0,t.jsx)(n.td,{children:"Request-specific, comparison logic"}),(0,t.jsx)(n.td,{children:"Conditions"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"https://github.com/openfga/sample-stores/tree/main/stores/ip-based-access",children:"IP-Based Access"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Email verification"})}),(0,t.jsx)(n.td,{children:"Boolean flag"}),(0,t.jsx)(n.td,{children:"Boolean relationships"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"https://github.com/openfga/sample-stores/blob/main/stores/abac-with-rebac/store.fga.yaml",children:"ABAC with ReBAC"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Department access"})}),(0,t.jsx)(n.td,{children:"Categorical relationship"}),(0,t.jsx)(n.td,{children:"Categorical relationships"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"/pr-preview/pr-1126/docs/modeling/organization-context-authorization",children:"Organization Context"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"JWT group claims"})}),(0,t.jsx)(n.td,{children:"Readily available"}),(0,t.jsx)(n.td,{children:"Contextual tuples"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"/pr-preview/pr-1126/docs/modeling/token-claims-contextual-tuples",children:"Token Claims"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Resource tagging"})}),(0,t.jsx)(n.td,{children:"Multiple attributes, policy-driven"}),(0,t.jsx)(n.td,{children:"Resource tagging"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"https://github.com/openfga/sample-stores/tree/main/stores/groups-resource-attributes",children:"Resource Attributes"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Usage quotas"})}),(0,t.jsx)(n.td,{children:"Requires calculations"}),(0,t.jsx)(n.td,{children:"Conditions"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"https://github.com/openfga/sample-stores/tree/main/stores/advanced-entitlements",children:"Entitlements"})})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"decision-framework-details",children:"Decision Framework Details"}),"\n",(0,t.jsx)(n.h3,{id:"1-request-specific-attributes-and-runtime-comparisons",children:"1. Request-Specific Attributes and Runtime Comparisons"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Question:"})," Does the attribute value change with every request, or do you need to compare stored policy values against runtime state?"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"\u2705 Request-specific: current time, IP address, transaction amount, device type"}),"\n",(0,t.jsx)(n.li,{children:"\u2705 Runtime comparisons: current usage vs. quota limit, current count vs. threshold"}),"\n",(0,t.jsx)(n.li,{children:"\u274c Not request-specific: user's department, document owner, email_verified"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Recommendation:"})," Use Conditions for:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Request-specific attributes that change per request (never store these as tuples)"}),"\n",(0,t.jsx)(n.li,{children:"Comparing stored policy values (limits, thresholds) against runtime state (current usage, counts)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Pattern for runtime comparisons:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Store the policy limit in the tuple's condition context (e.g., ",(0,t.jsx)(n.code,{children:"max_invites: 5"}),")"]}),"\n",(0,t.jsx)(n.li,{children:"Fetch the current runtime value before the check (e.g., from database)"}),"\n",(0,t.jsxs)(n.li,{children:["Provide the runtime value in the check's context (e.g., ",(0,t.jsx)(n.code,{children:"current_invite_count: 3"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:["Condition evaluates the comparison (e.g., ",(0,t.jsx)(n.code,{children:"current_invite_count < max_invites"}),")"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"2-boolean-flags",children:"2. Boolean Flags"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Question:"})," Is the attribute a true/false flag?"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"\u2705 Boolean: email_verified, account_active, terms_accepted, document.published"}),"\n",(0,t.jsx)(n.li,{children:"\u274c Not boolean: user_age, document_status (multiple values), credit_score"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Recommendation:"})," Use boolean self-relationships for binary flags that need to be checked across permissions."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Implementation options:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Self-referential:"})," ",(0,t.jsx)(n.code,{children:"user:alice \u2192 email_verified \u2192 user:alice"})," (preferred - clearer intent)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["Using ",(0,t.jsx)(n.code,{children:"user:*"}),":"]})," ",(0,t.jsx)(n.code,{children:"user:* \u2192 email_verified \u2192 user:alice"})," (valid alternative)"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"3-multiple-resource-attributes",children:"3. Multiple Resource Attributes"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Question:"})," Does the resource have multiple independent attributes that together determine access?"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"\u2705 Multiple attributes: document with (status, sensitivity, department)"}),"\n",(0,t.jsx)(n.li,{children:"\u274c Single attribute: document with just status"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Recommendation:"})," Use resource tagging when you need flexible, policy-driven access based on combinations of attribute values. Administrators can define which groups access which attribute combinations without model changes."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"4-readily-available-attributes",children:"4. Readily Available Attributes"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Question:"})," Is the attribute already in your JWT, session, or request context?"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"\u2705 Readily available: JWT claims (groups, roles), session tenant ID, request metadata"}),"\n",(0,t.jsx)(n.li,{children:"\u274c Requires lookup: user's manager, subscription level, resource owner"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"For readily available attributes:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use Contextual Tuples (JWT claims, session data)"}),"\n",(0,t.jsx)(n.li,{children:"Use Conditions (request metadata like IP, time)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"For attributes requiring lookups:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Sync to OpenFGA if infrequent changes"}),"\n",(0,t.jsx)(n.li,{children:"Evaluate: sync cost vs. per-request lookup cost"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Start simple:"})," Use categorical relationships when possible. Add complexity only when needed."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Minimize contextual tuples:"})," They limit API usage and complicate permission-aware search. Prefer stored tuples for stable data."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Know the limits:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Condition context in tuples: 32KB"}),"\n",(0,t.jsx)(n.li,{children:"Request context: 512KB"}),"\n",(0,t.jsx)(n.li,{children:"CEL evaluation cost: 100 (default)"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Plan synchronization:"})," For stored tuples, design sync early:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Event-driven updates (webhooks, queues)"}),"\n",(0,t.jsx)(n.li,{children:"Batch synchronization"}),"\n",(0,t.jsx)(n.li,{children:"Acceptable lag tolerance"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Optimize for queries:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Need ListObjects/ListUsers? \u2192 Use tuples"}),"\n",(0,t.jsx)(n.li,{children:"Only Check? \u2192 Contextual tuples viable"}),"\n",(0,t.jsx)(n.li,{children:"Build permission-aware search indexes when needed"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use consistent examples:"})," Within your organization, standardize on patterns to make models more understandable."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"decision-tree",children:"Decision Tree"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"START: What type of attribute?\n\n1. Request-specific OR needs runtime comparison? (time, IP, usage vs limit)\n   YES \u2192 Use Conditions (Approach 3)\n   NO \u2192 Continue\n\n2. Boolean flag? (email_verified, active)\n   YES \u2192 Use Boolean Relationships (Approach 2)\n   NO \u2192 Continue\n\n3. Multiple resource tags? (status + sensitivity + dept)\n   YES \u2192 Use Resource Tagging (Approach 4)\n   NO \u2192 Continue\n\n4. Readily available? (JWT claims, session data)\n   YES \u2192 Use Contextual Tuples (Approach 5)\n   NO \u2192 Use Categorical Relationships (Approach 1)\n\nComplex scenario with mixed types?\n   \u2192 Use Hybrid Approach (Approach 6)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"related-sections",children:"Related Sections"}),"\n",(0,t.jsx)(a.XQ,{description:"Learn more about implementing ABAC scenarios with OpenFGA",relatedLinks:[{title:"Conditions",description:"Learn how to use Conditions to model attribute-based policies.",link:"../modeling/conditions",id:"../modeling/conditions.mdx"},{title:"Token Claims as Contextual Tuples",description:"Use identity token claims to define contextual relationships.",link:"../modeling/token-claims-contextual-tuples",id:"../modeling/token-claims-contextual-tuples.mdx"},{title:"Contextual and Time-Based Authorization",description:"Authorize access based on dynamic or contextual criteria.",link:"../modeling/contextual-time-based-authorization",id:"../modeling/contextual-time-based-authorization.mdx"},{title:"Adoption Patterns",description:"Patterns for adopting OpenFGA in your organization.",link:"./adoption-patterns",id:"./adoption-patterns.mdx"},{title:"Sample Stores",description:"See practical examples of ABAC implementations.",link:"https://github.com/openfga/sample-stores"}]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}}}]);